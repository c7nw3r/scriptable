# Generated from Hypothesis.g4 by ANTLR 4.9.2
# encoding: utf-8
import sys
from io import StringIO

from antlr4 import *

if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\66")
        buf.write("\u0180\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\3\2\3\2\3\2\3\3\3\3\5\3h\n\3")
        buf.write("\3\4\3\4\3\4\3\4\3\4\5\4o\n\4\3\5\3\5\3\5\3\5\3\5\5\5")
        buf.write("v\n\5\3\6\3\6\5\6z\n\6\3\7\3\7\3\7\3\7\3\7\5\7\u0081\n")
        buf.write("\7\3\b\3\b\3\t\3\t\3\n\3\n\3\13\3\13\3\f\3\f\3\r\3\r\3")
        buf.write("\16\3\16\3\17\3\17\3\20\3\20\3\21\3\21\3\22\3\22\3\23")
        buf.write("\3\23\3\24\3\24\3\25\3\25\3\26\3\26\5\26\u00a1\n\26\3")
        buf.write("\26\3\26\3\26\5\26\u00a6\n\26\6\26\u00a8\n\26\r\26\16")
        buf.write("\26\u00a9\3\27\3\27\3\27\3\27\3\27\6\27\u00b1\n\27\r\27")
        buf.write("\16\27\u00b2\3\27\5\27\u00b6\n\27\3\27\3\27\3\30\3\30")
        buf.write("\5\30\u00bc\n\30\3\31\3\31\3\31\3\31\3\31\5\31\u00c3\n")
        buf.write("\31\3\32\3\32\5\32\u00c7\n\32\3\32\3\32\3\32\5\32\u00cc")
        buf.write("\n\32\7\32\u00ce\n\32\f\32\16\32\u00d1\13\32\3\33\3\33")
        buf.write("\3\33\3\33\3\33\6\33\u00d8\n\33\r\33\16\33\u00d9\3\33")
        buf.write("\5\33\u00dd\n\33\3\33\3\33\3\34\3\34\5\34\u00e3\n\34\3")
        buf.write("\35\3\35\3\35\3\35\3\35\3\35\5\35\u00eb\n\35\3\36\3\36")
        buf.write("\5\36\u00ef\n\36\3\36\3\36\3\36\5\36\u00f4\n\36\6\36\u00f6")
        buf.write("\n\36\r\36\16\36\u00f7\3\37\3\37\3\37\3\37\3\37\6\37\u00ff")
        buf.write("\n\37\r\37\16\37\u0100\3\37\5\37\u0104\n\37\3\37\3\37")
        buf.write("\3 \3 \3!\3!\5!\u010c\n!\3\"\3\"\5\"\u0110\n\"\3\"\3\"")
        buf.write("\3\"\5\"\u0115\n\"\6\"\u0117\n\"\r\"\16\"\u0118\3#\3#")
        buf.write("\3#\3#\3#\6#\u0120\n#\r#\16#\u0121\3#\5#\u0125\n#\3#\3")
        buf.write("#\3$\3$\3%\3%\3%\5%\u012e\n%\3&\3&\3&\3&\5&\u0134\n&\3")
        buf.write("\'\3\'\5\'\u0138\n\'\3\'\3\'\3\'\3(\3(\3(\3(\6(\u0141")
        buf.write("\n(\r(\16(\u0142\3)\3)\3*\3*\3+\3+\5+\u014b\n+\3,\3,\3")
        buf.write(",\3,\3,\3,\5,\u0153\n,\3,\3,\6,\u0157\n,\r,\16,\u0158")
        buf.write("\3-\3-\3.\3.\3/\3/\3\60\3\60\3\60\3\60\7\60\u0165\n\60")
        buf.write("\f\60\16\60\u0168\13\60\5\60\u016a\n\60\3\60\3\60\3\61")
        buf.write("\3\61\3\61\3\61\3\61\3\61\3\61\3\61\3\61\7\61\u0177\n")
        buf.write("\61\f\61\16\61\u017a\13\61\5\61\u017c\n\61\3\61\3\61\3")
        buf.write("\61\2\2\62\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$")
        buf.write("&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`\2\6\3\2\27\30")
        buf.write("\3\2\31\32\3\2#%\3\2\3\4\2\u018a\2b\3\2\2\2\4g\3\2\2\2")
        buf.write("\6n\3\2\2\2\bu\3\2\2\2\ny\3\2\2\2\f\u0080\3\2\2\2\16\u0082")
        buf.write("\3\2\2\2\20\u0084\3\2\2\2\22\u0086\3\2\2\2\24\u0088\3")
        buf.write("\2\2\2\26\u008a\3\2\2\2\30\u008c\3\2\2\2\32\u008e\3\2")
        buf.write("\2\2\34\u0090\3\2\2\2\36\u0092\3\2\2\2 \u0094\3\2\2\2")
        buf.write("\"\u0096\3\2\2\2$\u0098\3\2\2\2&\u009a\3\2\2\2(\u009c")
        buf.write("\3\2\2\2*\u00a0\3\2\2\2,\u00ab\3\2\2\2.\u00bb\3\2\2\2")
        buf.write("\60\u00c2\3\2\2\2\62\u00c6\3\2\2\2\64\u00d2\3\2\2\2\66")
        buf.write("\u00e2\3\2\2\28\u00ea\3\2\2\2:\u00ee\3\2\2\2<\u00f9\3")
        buf.write("\2\2\2>\u0107\3\2\2\2@\u010b\3\2\2\2B\u010f\3\2\2\2D\u011a")
        buf.write("\3\2\2\2F\u0128\3\2\2\2H\u012d\3\2\2\2J\u012f\3\2\2\2")
        buf.write("L\u0137\3\2\2\2N\u013c\3\2\2\2P\u0144\3\2\2\2R\u0146\3")
        buf.write("\2\2\2T\u014a\3\2\2\2V\u014c\3\2\2\2X\u015a\3\2\2\2Z\u015c")
        buf.write("\3\2\2\2\\\u015e\3\2\2\2^\u0160\3\2\2\2`\u016d\3\2\2\2")
        buf.write("bc\5\b\5\2cd\7\2\2\3d\3\3\2\2\2eh\5Z.\2fh\5R*\2ge\3\2")
        buf.write("\2\2gf\3\2\2\2h\5\3\2\2\2io\5\16\b\2jo\5\20\t\2ko\5\22")
        buf.write("\n\2lo\5\24\13\2mo\5\26\f\2ni\3\2\2\2nj\3\2\2\2nk\3\2")
        buf.write("\2\2nl\3\2\2\2nm\3\2\2\2o\7\3\2\2\2pv\5H%\2qv\5*\26\2")
        buf.write("rv\5\62\32\2sv\5:\36\2tv\5B\"\2up\3\2\2\2uq\3\2\2\2ur")
        buf.write("\3\2\2\2us\3\2\2\2ut\3\2\2\2v\t\3\2\2\2wz\5,\27\2xz\5")
        buf.write("\64\33\2yw\3\2\2\2yx\3\2\2\2z\13\3\2\2\2{\u0081\5Z.\2")
        buf.write("|\u0081\5\\/\2}\u0081\5X-\2~\u0081\5^\60\2\177\u0081\5")
        buf.write("`\61\2\u0080{\3\2\2\2\u0080|\3\2\2\2\u0080}\3\2\2\2\u0080")
        buf.write("~\3\2\2\2\u0080\177\3\2\2\2\u0081\r\3\2\2\2\u0082\u0083")
        buf.write("\7\t\2\2\u0083\17\3\2\2\2\u0084\u0085\7\n\2\2\u0085\21")
        buf.write("\3\2\2\2\u0086\u0087\7\13\2\2\u0087\23\3\2\2\2\u0088\u0089")
        buf.write("\7\f\2\2\u0089\25\3\2\2\2\u008a\u008b\7\r\2\2\u008b\27")
        buf.write("\3\2\2\2\u008c\u008d\7\24\2\2\u008d\31\3\2\2\2\u008e\u008f")
        buf.write("\7\25\2\2\u008f\33\3\2\2\2\u0090\u0091\7\26\2\2\u0091")
        buf.write("\35\3\2\2\2\u0092\u0093\t\2\2\2\u0093\37\3\2\2\2\u0094")
        buf.write("\u0095\t\3\2\2\u0095!\3\2\2\2\u0096\u0097\7\33\2\2\u0097")
        buf.write("#\3\2\2\2\u0098\u0099\7\34\2\2\u0099%\3\2\2\2\u009a\u009b")
        buf.write("\7\35\2\2\u009b\'\3\2\2\2\u009c\u009d\7\36\2\2\u009d)")
        buf.write("\3\2\2\2\u009e\u00a1\5\4\3\2\u009f\u00a1\5,\27\2\u00a0")
        buf.write("\u009e\3\2\2\2\u00a0\u009f\3\2\2\2\u00a1\u00a7\3\2\2\2")
        buf.write("\u00a2\u00a5\5\6\4\2\u00a3\u00a6\5\4\3\2\u00a4\u00a6\5")
        buf.write(",\27\2\u00a5\u00a3\3\2\2\2\u00a5\u00a4\3\2\2\2\u00a6\u00a8")
        buf.write("\3\2\2\2\u00a7\u00a2\3\2\2\2\u00a8\u00a9\3\2\2\2\u00a9")
        buf.write("\u00a7\3\2\2\2\u00a9\u00aa\3\2\2\2\u00aa+\3\2\2\2\u00ab")
        buf.write("\u00b5\7\16\2\2\u00ac\u00b0\5\4\3\2\u00ad\u00ae\5\6\4")
        buf.write("\2\u00ae\u00af\5\4\3\2\u00af\u00b1\3\2\2\2\u00b0\u00ad")
        buf.write("\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\u00b0\3\2\2\2\u00b2")
        buf.write("\u00b3\3\2\2\2\u00b3\u00b6\3\2\2\2\u00b4\u00b6\5,\27\2")
        buf.write("\u00b5\u00ac\3\2\2\2\u00b5\u00b4\3\2\2\2\u00b6\u00b7\3")
        buf.write("\2\2\2\u00b7\u00b8\7\17\2\2\u00b8-\3\2\2\2\u00b9\u00bc")
        buf.write("\5\f\7\2\u00ba\u00bc\5R*\2\u00bb\u00b9\3\2\2\2\u00bb\u00ba")
        buf.write("\3\2\2\2\u00bc/\3\2\2\2\u00bd\u00c3\5\30\r\2\u00be\u00c3")
        buf.write("\5\32\16\2\u00bf\u00c3\5\34\17\2\u00c0\u00c3\5\36\20\2")
        buf.write("\u00c1\u00c3\5 \21\2\u00c2\u00bd\3\2\2\2\u00c2\u00be\3")
        buf.write("\2\2\2\u00c2\u00bf\3\2\2\2\u00c2\u00c0\3\2\2\2\u00c2\u00c1")
        buf.write("\3\2\2\2\u00c3\61\3\2\2\2\u00c4\u00c7\5.\30\2\u00c5\u00c7")
        buf.write("\5\64\33\2\u00c6\u00c4\3\2\2\2\u00c6\u00c5\3\2\2\2\u00c7")
        buf.write("\u00cf\3\2\2\2\u00c8\u00cb\5\60\31\2\u00c9\u00cc\5.\30")
        buf.write("\2\u00ca\u00cc\5\64\33\2\u00cb\u00c9\3\2\2\2\u00cb\u00ca")
        buf.write("\3\2\2\2\u00cc\u00ce\3\2\2\2\u00cd\u00c8\3\2\2\2\u00ce")
        buf.write("\u00d1\3\2\2\2\u00cf\u00cd\3\2\2\2\u00cf\u00d0\3\2\2\2")
        buf.write("\u00d0\63\3\2\2\2\u00d1\u00cf\3\2\2\2\u00d2\u00dc\7\16")
        buf.write("\2\2\u00d3\u00d7\5.\30\2\u00d4\u00d5\5\60\31\2\u00d5\u00d6")
        buf.write("\5.\30\2\u00d6\u00d8\3\2\2\2\u00d7\u00d4\3\2\2\2\u00d8")
        buf.write("\u00d9\3\2\2\2\u00d9\u00d7\3\2\2\2\u00d9\u00da\3\2\2\2")
        buf.write("\u00da\u00dd\3\2\2\2\u00db\u00dd\5\64\33\2\u00dc\u00d3")
        buf.write("\3\2\2\2\u00dc\u00db\3\2\2\2\u00dd\u00de\3\2\2\2\u00de")
        buf.write("\u00df\7\17\2\2\u00df\65\3\2\2\2\u00e0\u00e3\5Z.\2\u00e1")
        buf.write("\u00e3\5R*\2\u00e2\u00e0\3\2\2\2\u00e2\u00e1\3\2\2\2\u00e3")
        buf.write("\67\3\2\2\2\u00e4\u00eb\5\36\20\2\u00e5\u00eb\5 \21\2")
        buf.write("\u00e6\u00eb\5\"\22\2\u00e7\u00eb\5$\23\2\u00e8\u00eb")
        buf.write("\5&\24\2\u00e9\u00eb\5(\25\2\u00ea\u00e4\3\2\2\2\u00ea")
        buf.write("\u00e5\3\2\2\2\u00ea\u00e6\3\2\2\2\u00ea\u00e7\3\2\2\2")
        buf.write("\u00ea\u00e8\3\2\2\2\u00ea\u00e9\3\2\2\2\u00eb9\3\2\2")
        buf.write("\2\u00ec\u00ef\5\66\34\2\u00ed\u00ef\5<\37\2\u00ee\u00ec")
        buf.write("\3\2\2\2\u00ee\u00ed\3\2\2\2\u00ef\u00f5\3\2\2\2\u00f0")
        buf.write("\u00f3\58\35\2\u00f1\u00f4\5\66\34\2\u00f2\u00f4\5<\37")
        buf.write("\2\u00f3\u00f1\3\2\2\2\u00f3\u00f2\3\2\2\2\u00f4\u00f6")
        buf.write("\3\2\2\2\u00f5\u00f0\3\2\2\2\u00f6\u00f7\3\2\2\2\u00f7")
        buf.write("\u00f5\3\2\2\2\u00f7\u00f8\3\2\2\2\u00f8;\3\2\2\2\u00f9")
        buf.write("\u0103\7\16\2\2\u00fa\u00fe\5\66\34\2\u00fb\u00fc\58\35")
        buf.write("\2\u00fc\u00fd\5\66\34\2\u00fd\u00ff\3\2\2\2\u00fe\u00fb")
        buf.write("\3\2\2\2\u00ff\u0100\3\2\2\2\u0100\u00fe\3\2\2\2\u0100")
        buf.write("\u0101\3\2\2\2\u0101\u0104\3\2\2\2\u0102\u0104\5<\37\2")
        buf.write("\u0103\u00fa\3\2\2\2\u0103\u0102\3\2\2\2\u0104\u0105\3")
        buf.write("\2\2\2\u0105\u0106\7\17\2\2\u0106=\3\2\2\2\u0107\u0108")
        buf.write("\5X-\2\u0108?\3\2\2\2\u0109\u010c\5\36\20\2\u010a\u010c")
        buf.write("\5 \21\2\u010b\u0109\3\2\2\2\u010b\u010a\3\2\2\2\u010c")
        buf.write("A\3\2\2\2\u010d\u0110\5> \2\u010e\u0110\5D#\2\u010f\u010d")
        buf.write("\3\2\2\2\u010f\u010e\3\2\2\2\u0110\u0116\3\2\2\2\u0111")
        buf.write("\u0114\5@!\2\u0112\u0115\5> \2\u0113\u0115\5D#\2\u0114")
        buf.write("\u0112\3\2\2\2\u0114\u0113\3\2\2\2\u0115\u0117\3\2\2\2")
        buf.write("\u0116\u0111\3\2\2\2\u0117\u0118\3\2\2\2\u0118\u0116\3")
        buf.write("\2\2\2\u0118\u0119\3\2\2\2\u0119C\3\2\2\2\u011a\u0124")
        buf.write("\7\16\2\2\u011b\u011f\5> \2\u011c\u011d\5@!\2\u011d\u011e")
        buf.write("\5> \2\u011e\u0120\3\2\2\2\u011f\u011c\3\2\2\2\u0120\u0121")
        buf.write("\3\2\2\2\u0121\u011f\3\2\2\2\u0121\u0122\3\2\2\2\u0122")
        buf.write("\u0125\3\2\2\2\u0123\u0125\5D#\2\u0124\u011b\3\2\2\2\u0124")
        buf.write("\u0123\3\2\2\2\u0125\u0126\3\2\2\2\u0126\u0127\7\17\2")
        buf.write("\2\u0127E\3\2\2\2\u0128\u0129\5X-\2\u0129G\3\2\2\2\u012a")
        buf.write("\u012e\5N(\2\u012b\u012e\5J&\2\u012c\u012e\5L\'\2\u012d")
        buf.write("\u012a\3\2\2\2\u012d\u012b\3\2\2\2\u012d\u012c\3\2\2\2")
        buf.write("\u012eI\3\2\2\2\u012f\u0130\5X-\2\u0130\u0133\5\16\b\2")
        buf.write("\u0131\u0134\5\f\7\2\u0132\u0134\5R*\2\u0133\u0131\3\2")
        buf.write("\2\2\u0133\u0132\3\2\2\2\u0134K\3\2\2\2\u0135\u0138\5")
        buf.write("\f\7\2\u0136\u0138\5R*\2\u0137\u0135\3\2\2\2\u0137\u0136")
        buf.write("\3\2\2\2\u0138\u0139\3\2\2\2\u0139\u013a\5\16\b\2\u013a")
        buf.write("\u013b\5X-\2\u013bM\3\2\2\2\u013c\u0140\5X-\2\u013d\u013e")
        buf.write("\5\16\b\2\u013e\u013f\5X-\2\u013f\u0141\3\2\2\2\u0140")
        buf.write("\u013d\3\2\2\2\u0141\u0142\3\2\2\2\u0142\u0140\3\2\2\2")
        buf.write("\u0142\u0143\3\2\2\2\u0143O\3\2\2\2\u0144\u0145\t\4\2")
        buf.write("\2\u0145Q\3\2\2\2\u0146\u0147\7\61\2\2\u0147S\3\2\2\2")
        buf.write("\u0148\u014b\5X-\2\u0149\u014b\5R*\2\u014a\u0148\3\2\2")
        buf.write("\2\u014a\u0149\3\2\2\2\u014bU\3\2\2\2\u014c\u0156\5T+")
        buf.write("\2\u014d\u014e\7\5\2\2\u014e\u0157\5R*\2\u014f\u0152\7")
        buf.write("\22\2\2\u0150\u0153\5Z.\2\u0151\u0153\5X-\2\u0152\u0150")
        buf.write("\3\2\2\2\u0152\u0151\3\2\2\2\u0153\u0154\3\2\2\2\u0154")
        buf.write("\u0155\7\23\2\2\u0155\u0157\3\2\2\2\u0156\u014d\3\2\2")
        buf.write("\2\u0156\u014f\3\2\2\2\u0157\u0158\3\2\2\2\u0158\u0156")
        buf.write("\3\2\2\2\u0158\u0159\3\2\2\2\u0159W\3\2\2\2\u015a\u015b")
        buf.write("\7\62\2\2\u015bY\3\2\2\2\u015c\u015d\7\63\2\2\u015d[\3")
        buf.write("\2\2\2\u015e\u015f\t\5\2\2\u015f]\3\2\2\2\u0160\u0169")
        buf.write("\7\22\2\2\u0161\u0166\5\f\7\2\u0162\u0163\7\7\2\2\u0163")
        buf.write("\u0165\5\f\7\2\u0164\u0162\3\2\2\2\u0165\u0168\3\2\2\2")
        buf.write("\u0166\u0164\3\2\2\2\u0166\u0167\3\2\2\2\u0167\u016a\3")
        buf.write("\2\2\2\u0168\u0166\3\2\2\2\u0169\u0161\3\2\2\2\u0169\u016a")
        buf.write("\3\2\2\2\u016a\u016b\3\2\2\2\u016b\u016c\7\23\2\2\u016c")
        buf.write("_\3\2\2\2\u016d\u017b\7\20\2\2\u016e\u016f\5X-\2\u016f")
        buf.write("\u0170\7\6\2\2\u0170\u0178\5\f\7\2\u0171\u0172\7\7\2\2")
        buf.write("\u0172\u0173\5X-\2\u0173\u0174\7\6\2\2\u0174\u0175\5\f")
        buf.write("\7\2\u0175\u0177\3\2\2\2\u0176\u0171\3\2\2\2\u0177\u017a")
        buf.write("\3\2\2\2\u0178\u0176\3\2\2\2\u0178\u0179\3\2\2\2\u0179")
        buf.write("\u017c\3\2\2\2\u017a\u0178\3\2\2\2\u017b\u016e\3\2\2\2")
        buf.write("\u017b\u017c\3\2\2\2\u017c\u017d\3\2\2\2\u017d\u017e\7")
        buf.write("\21\2\2\u017ea\3\2\2\2,gnuy\u0080\u00a0\u00a5\u00a9\u00b2")
        buf.write("\u00b5\u00bb\u00c2\u00c6\u00cb\u00cf\u00d9\u00dc\u00e2")
        buf.write("\u00ea\u00ee\u00f3\u00f7\u0100\u0103\u010b\u010f\u0114")
        buf.write("\u0118\u0121\u0124\u012d\u0133\u0137\u0142\u014a\u0152")
        buf.write("\u0156\u0158\u0166\u0169\u0178\u017b")
        return buf.getvalue()


class HypothesisParser ( Parser ):

    grammarFileName = "Hypothesis.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'true'", "'false'", "'.'", "':'", "','", 
                     "';'", "'+'", "'-'", "'*'", "'/'", "'**'", "'('", "')'", 
                     "'{'", "'}'", "'['", "']'", "'&&'", "'||'", "'!'", 
                     "'=='", "'==='", "'!='", "'!=='", "'<'", "'<='", "'>'", 
                     "'>='", "'if'", "'else'", "'return'", "'function'", 
                     "'string'", "'number'", "'boolean'", "'=>'", "'while'", 
                     "'for'", "'in'", "'of'", "'const'", "'var'", "'let'", 
                     "'='", "'break'", "'continue'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "' '" ]

    symbolicNames = [ "<INVALID>", "TRUE", "FALSE", "DOT", "COLON", "COMMA", 
                      "SEMICOLON", "PLUS", "MINUS", "MUL", "DIV", "POWER", 
                      "ROUND_LEFT", "ROUND_RIGHT", "CURLY_LEFT", "CURLY_RIGHT", 
                      "BRACKET_LEFT", "BRACKET_RIGHT", "AND", "OR", "NOT", 
                      "EQ", "STRICT_EQ", "NEQ", "STRICT_NEQ", "LT", "LE", 
                      "GT", "GE", "IF", "ELSE", "RETURN", "FUNCTION", "STRING", 
                      "NUMBER", "BOOLEAN", "ARROW", "WHILE", "FOR", "IN", 
                      "OF", "CONST", "VAR", "LET", "EQUAL", "BREAK", "CONTINUE", 
                      "IDENTIFIER", "CHARS", "DIGITS", "WS", "LINE_COMMENT", 
                      "WHITESPACE" ]

    RULE_sAll = 0
    RULE_sOperand = 1
    RULE_sOperator = 2
    RULE_sExpression = 3
    RULE_sTerm = 4
    RULE_sValue = 5
    RULE_sPlus = 6
    RULE_sMinus = 7
    RULE_sMul = 8
    RULE_sDiv = 9
    RULE_sPower = 10
    RULE_sAnd = 11
    RULE_sOr = 12
    RULE_sNot = 13
    RULE_sEquals = 14
    RULE_sNotEquals = 15
    RULE_sLowerThan = 16
    RULE_sLowerEquals = 17
    RULE_sGreaterThan = 18
    RULE_sGreaterEquals = 19
    RULE_sArithmeticExpression = 20
    RULE_sArithmeticTerm = 21
    RULE_sBooleanOperand = 22
    RULE_sBooleanOperator = 23
    RULE_sBooleanExpression = 24
    RULE_sBooleanTerm = 25
    RULE_sNumberOperand = 26
    RULE_sNumberOperator = 27
    RULE_sNumberExpression = 28
    RULE_sNumberTerm = 29
    RULE_sStringOperand = 30
    RULE_sStringOperator = 31
    RULE_sStringExpression = 32
    RULE_sStringTerm = 33
    RULE_sConcatOperand = 34
    RULE_sConcatExpression = 35
    RULE_sConcatLeft = 36
    RULE_sConcatRight = 37
    RULE_sConcatBoth = 38
    RULE_sType = 39
    RULE_sProperty = 40
    RULE_sPropertyAware = 41
    RULE_sPropertyAccess = 42
    RULE_sString = 43
    RULE_sNumber = 44
    RULE_sBoolean = 45
    RULE_sArray = 46
    RULE_sMap = 47

    ruleNames =  [ "sAll", "sOperand", "sOperator", "sExpression", "sTerm", 
                   "sValue", "sPlus", "sMinus", "sMul", "sDiv", "sPower", 
                   "sAnd", "sOr", "sNot", "sEquals", "sNotEquals", "sLowerThan", 
                   "sLowerEquals", "sGreaterThan", "sGreaterEquals", "sArithmeticExpression", 
                   "sArithmeticTerm", "sBooleanOperand", "sBooleanOperator", 
                   "sBooleanExpression", "sBooleanTerm", "sNumberOperand", 
                   "sNumberOperator", "sNumberExpression", "sNumberTerm", 
                   "sStringOperand", "sStringOperator", "sStringExpression", 
                   "sStringTerm", "sConcatOperand", "sConcatExpression", 
                   "sConcatLeft", "sConcatRight", "sConcatBoth", "sType", 
                   "sProperty", "sPropertyAware", "sPropertyAccess", "sString", 
                   "sNumber", "sBoolean", "sArray", "sMap" ]

    EOF = Token.EOF
    TRUE=1
    FALSE=2
    DOT=3
    COLON=4
    COMMA=5
    SEMICOLON=6
    PLUS=7
    MINUS=8
    MUL=9
    DIV=10
    POWER=11
    ROUND_LEFT=12
    ROUND_RIGHT=13
    CURLY_LEFT=14
    CURLY_RIGHT=15
    BRACKET_LEFT=16
    BRACKET_RIGHT=17
    AND=18
    OR=19
    NOT=20
    EQ=21
    STRICT_EQ=22
    NEQ=23
    STRICT_NEQ=24
    LT=25
    LE=26
    GT=27
    GE=28
    IF=29
    ELSE=30
    RETURN=31
    FUNCTION=32
    STRING=33
    NUMBER=34
    BOOLEAN=35
    ARROW=36
    WHILE=37
    FOR=38
    IN=39
    OF=40
    CONST=41
    VAR=42
    LET=43
    EQUAL=44
    BREAK=45
    CONTINUE=46
    IDENTIFIER=47
    CHARS=48
    DIGITS=49
    WS=50
    LINE_COMMENT=51
    WHITESPACE=52

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class SAllContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SExpressionContext,0)


        def EOF(self):
            return self.getToken(HypothesisParser.EOF, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sAll

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSAll" ):
                listener.enterSAll(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSAll" ):
                listener.exitSAll(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSAll" ):
                return visitor.visitSAll(self)
            else:
                return visitor.visitChildren(self)




    def sAll(self):

        localctx = HypothesisParser.SAllContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_sAll)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.sExpression()
            self.state = 97
            self.match(HypothesisParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sNumber(self):
            return self.getTypedRuleContext(HypothesisParser.SNumberContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSOperand" ):
                listener.enterSOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSOperand" ):
                listener.exitSOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSOperand" ):
                return visitor.visitSOperand(self)
            else:
                return visitor.visitChildren(self)




    def sOperand(self):

        localctx = HypothesisParser.SOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sOperand)
        try:
            self.state = 101
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.DIGITS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 99
                self.sNumber()
                pass
            elif token in [HypothesisParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 100
                self.sProperty()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sPlus(self):
            return self.getTypedRuleContext(HypothesisParser.SPlusContext,0)


        def sMinus(self):
            return self.getTypedRuleContext(HypothesisParser.SMinusContext,0)


        def sMul(self):
            return self.getTypedRuleContext(HypothesisParser.SMulContext,0)


        def sDiv(self):
            return self.getTypedRuleContext(HypothesisParser.SDivContext,0)


        def sPower(self):
            return self.getTypedRuleContext(HypothesisParser.SPowerContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSOperator" ):
                listener.enterSOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSOperator" ):
                listener.exitSOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSOperator" ):
                return visitor.visitSOperator(self)
            else:
                return visitor.visitChildren(self)




    def sOperator(self):

        localctx = HypothesisParser.SOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_sOperator)
        try:
            self.state = 108
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.PLUS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 103
                self.sPlus()
                pass
            elif token in [HypothesisParser.MINUS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 104
                self.sMinus()
                pass
            elif token in [HypothesisParser.MUL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 105
                self.sMul()
                pass
            elif token in [HypothesisParser.DIV]:
                self.enterOuterAlt(localctx, 4)
                self.state = 106
                self.sDiv()
                pass
            elif token in [HypothesisParser.POWER]:
                self.enterOuterAlt(localctx, 5)
                self.state = 107
                self.sPower()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sConcatExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SConcatExpressionContext,0)


        def sArithmeticExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SArithmeticExpressionContext,0)


        def sBooleanExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SBooleanExpressionContext,0)


        def sNumberExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SNumberExpressionContext,0)


        def sStringExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SStringExpressionContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSExpression" ):
                listener.enterSExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSExpression" ):
                listener.exitSExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSExpression" ):
                return visitor.visitSExpression(self)
            else:
                return visitor.visitChildren(self)




    def sExpression(self):

        localctx = HypothesisParser.SExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_sExpression)
        try:
            self.state = 115
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 110
                self.sConcatExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 111
                self.sArithmeticExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 112
                self.sBooleanExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 113
                self.sNumberExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 114
                self.sStringExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class STermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sArithmeticTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SArithmeticTermContext,0)


        def sBooleanTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SBooleanTermContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSTerm" ):
                listener.enterSTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSTerm" ):
                listener.exitSTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSTerm" ):
                return visitor.visitSTerm(self)
            else:
                return visitor.visitChildren(self)




    def sTerm(self):

        localctx = HypothesisParser.STermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_sTerm)
        try:
            self.state = 119
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 117
                self.sArithmeticTerm()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 118
                self.sBooleanTerm()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sNumber(self):
            return self.getTypedRuleContext(HypothesisParser.SNumberContext,0)


        def sBoolean(self):
            return self.getTypedRuleContext(HypothesisParser.SBooleanContext,0)


        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def sArray(self):
            return self.getTypedRuleContext(HypothesisParser.SArrayContext,0)


        def sMap(self):
            return self.getTypedRuleContext(HypothesisParser.SMapContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSValue" ):
                listener.enterSValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSValue" ):
                listener.exitSValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSValue" ):
                return visitor.visitSValue(self)
            else:
                return visitor.visitChildren(self)




    def sValue(self):

        localctx = HypothesisParser.SValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_sValue)
        try:
            self.state = 126
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.DIGITS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 121
                self.sNumber()
                pass
            elif token in [HypothesisParser.TRUE, HypothesisParser.FALSE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 122
                self.sBoolean()
                pass
            elif token in [HypothesisParser.CHARS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 123
                self.sString()
                pass
            elif token in [HypothesisParser.BRACKET_LEFT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 124
                self.sArray()
                pass
            elif token in [HypothesisParser.CURLY_LEFT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 125
                self.sMap()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SPlusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(HypothesisParser.PLUS, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sPlus

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSPlus" ):
                listener.enterSPlus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSPlus" ):
                listener.exitSPlus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSPlus" ):
                return visitor.visitSPlus(self)
            else:
                return visitor.visitChildren(self)




    def sPlus(self):

        localctx = HypothesisParser.SPlusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_sPlus)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.match(HypothesisParser.PLUS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SMinusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(HypothesisParser.MINUS, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sMinus

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSMinus" ):
                listener.enterSMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSMinus" ):
                listener.exitSMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSMinus" ):
                return visitor.visitSMinus(self)
            else:
                return visitor.visitChildren(self)




    def sMinus(self):

        localctx = HypothesisParser.SMinusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_sMinus)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 130
            self.match(HypothesisParser.MINUS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SMulContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUL(self):
            return self.getToken(HypothesisParser.MUL, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sMul

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSMul" ):
                listener.enterSMul(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSMul" ):
                listener.exitSMul(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSMul" ):
                return visitor.visitSMul(self)
            else:
                return visitor.visitChildren(self)




    def sMul(self):

        localctx = HypothesisParser.SMulContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_sMul)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(HypothesisParser.MUL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SDivContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIV(self):
            return self.getToken(HypothesisParser.DIV, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sDiv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSDiv" ):
                listener.enterSDiv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSDiv" ):
                listener.exitSDiv(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSDiv" ):
                return visitor.visitSDiv(self)
            else:
                return visitor.visitChildren(self)




    def sDiv(self):

        localctx = HypothesisParser.SDivContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_sDiv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self.match(HypothesisParser.DIV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SPowerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POWER(self):
            return self.getToken(HypothesisParser.POWER, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sPower

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSPower" ):
                listener.enterSPower(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSPower" ):
                listener.exitSPower(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSPower" ):
                return visitor.visitSPower(self)
            else:
                return visitor.visitChildren(self)




    def sPower(self):

        localctx = HypothesisParser.SPowerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_sPower)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 136
            self.match(HypothesisParser.POWER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SAndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(HypothesisParser.AND, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sAnd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSAnd" ):
                listener.enterSAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSAnd" ):
                listener.exitSAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSAnd" ):
                return visitor.visitSAnd(self)
            else:
                return visitor.visitChildren(self)




    def sAnd(self):

        localctx = HypothesisParser.SAndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_sAnd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self.match(HypothesisParser.AND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SOrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OR(self):
            return self.getToken(HypothesisParser.OR, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sOr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSOr" ):
                listener.enterSOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSOr" ):
                listener.exitSOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSOr" ):
                return visitor.visitSOr(self)
            else:
                return visitor.visitChildren(self)




    def sOr(self):

        localctx = HypothesisParser.SOrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_sOr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(HypothesisParser.OR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNotContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(HypothesisParser.NOT, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sNot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNot" ):
                listener.enterSNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNot" ):
                listener.exitSNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNot" ):
                return visitor.visitSNot(self)
            else:
                return visitor.visitChildren(self)




    def sNot(self):

        localctx = HypothesisParser.SNotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_sNot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(HypothesisParser.NOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SEqualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(HypothesisParser.EQ, 0)

        def STRICT_EQ(self):
            return self.getToken(HypothesisParser.STRICT_EQ, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sEquals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSEquals" ):
                listener.enterSEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSEquals" ):
                listener.exitSEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSEquals" ):
                return visitor.visitSEquals(self)
            else:
                return visitor.visitChildren(self)




    def sEquals(self):

        localctx = HypothesisParser.SEqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_sEquals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            _la = self._input.LA(1)
            if not(_la==HypothesisParser.EQ or _la==HypothesisParser.STRICT_EQ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNotEqualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEQ(self):
            return self.getToken(HypothesisParser.NEQ, 0)

        def STRICT_NEQ(self):
            return self.getToken(HypothesisParser.STRICT_NEQ, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sNotEquals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNotEquals" ):
                listener.enterSNotEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNotEquals" ):
                listener.exitSNotEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNotEquals" ):
                return visitor.visitSNotEquals(self)
            else:
                return visitor.visitChildren(self)




    def sNotEquals(self):

        localctx = HypothesisParser.SNotEqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_sNotEquals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            _la = self._input.LA(1)
            if not(_la==HypothesisParser.NEQ or _la==HypothesisParser.STRICT_NEQ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SLowerThanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(HypothesisParser.LT, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sLowerThan

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSLowerThan" ):
                listener.enterSLowerThan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSLowerThan" ):
                listener.exitSLowerThan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSLowerThan" ):
                return visitor.visitSLowerThan(self)
            else:
                return visitor.visitChildren(self)




    def sLowerThan(self):

        localctx = HypothesisParser.SLowerThanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_sLowerThan)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            self.match(HypothesisParser.LT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SLowerEqualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LE(self):
            return self.getToken(HypothesisParser.LE, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sLowerEquals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSLowerEquals" ):
                listener.enterSLowerEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSLowerEquals" ):
                listener.exitSLowerEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSLowerEquals" ):
                return visitor.visitSLowerEquals(self)
            else:
                return visitor.visitChildren(self)




    def sLowerEquals(self):

        localctx = HypothesisParser.SLowerEqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_sLowerEquals)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(HypothesisParser.LE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SGreaterThanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GT(self):
            return self.getToken(HypothesisParser.GT, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sGreaterThan

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSGreaterThan" ):
                listener.enterSGreaterThan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSGreaterThan" ):
                listener.exitSGreaterThan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSGreaterThan" ):
                return visitor.visitSGreaterThan(self)
            else:
                return visitor.visitChildren(self)




    def sGreaterThan(self):

        localctx = HypothesisParser.SGreaterThanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_sGreaterThan)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self.match(HypothesisParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SGreaterEqualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GE(self):
            return self.getToken(HypothesisParser.GE, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sGreaterEquals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSGreaterEquals" ):
                listener.enterSGreaterEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSGreaterEquals" ):
                listener.exitSGreaterEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSGreaterEquals" ):
                return visitor.visitSGreaterEquals(self)
            else:
                return visitor.visitChildren(self)




    def sGreaterEquals(self):

        localctx = HypothesisParser.SGreaterEqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_sGreaterEquals)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(HypothesisParser.GE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SArithmeticExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SOperandContext,i)


        def sArithmeticTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SArithmeticTermContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SArithmeticTermContext,i)


        def sOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sArithmeticExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSArithmeticExpression" ):
                listener.enterSArithmeticExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSArithmeticExpression" ):
                listener.exitSArithmeticExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSArithmeticExpression" ):
                return visitor.visitSArithmeticExpression(self)
            else:
                return visitor.visitChildren(self)




    def sArithmeticExpression(self):

        localctx = HypothesisParser.SArithmeticExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_sArithmeticExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.IDENTIFIER, HypothesisParser.DIGITS]:
                self.state = 156
                self.sOperand()
                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 157
                self.sArithmeticTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 165 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 160
                self.sOperator()
                self.state = 163
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [HypothesisParser.IDENTIFIER, HypothesisParser.DIGITS]:
                    self.state = 161
                    self.sOperand()
                    pass
                elif token in [HypothesisParser.ROUND_LEFT]:
                    self.state = 162
                    self.sArithmeticTerm()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 167 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.PLUS) | (1 << HypothesisParser.MINUS) | (1 << HypothesisParser.MUL) | (1 << HypothesisParser.DIV) | (1 << HypothesisParser.POWER))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SArithmeticTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND_LEFT(self):
            return self.getToken(HypothesisParser.ROUND_LEFT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(HypothesisParser.ROUND_RIGHT, 0)

        def sArithmeticTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SArithmeticTermContext,0)


        def sOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SOperandContext,i)


        def sOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sArithmeticTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSArithmeticTerm" ):
                listener.enterSArithmeticTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSArithmeticTerm" ):
                listener.exitSArithmeticTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSArithmeticTerm" ):
                return visitor.visitSArithmeticTerm(self)
            else:
                return visitor.visitChildren(self)




    def sArithmeticTerm(self):

        localctx = HypothesisParser.SArithmeticTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_sArithmeticTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            self.match(HypothesisParser.ROUND_LEFT)
            self.state = 179
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.IDENTIFIER, HypothesisParser.DIGITS]:
                self.state = 170
                self.sOperand()
                self.state = 174 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 171
                    self.sOperator()
                    self.state = 172
                    self.sOperand()
                    self.state = 176 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.PLUS) | (1 << HypothesisParser.MINUS) | (1 << HypothesisParser.MUL) | (1 << HypothesisParser.DIV) | (1 << HypothesisParser.POWER))) != 0)):
                        break

                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 178
                self.sArithmeticTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 181
            self.match(HypothesisParser.ROUND_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SBooleanOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sValue(self):
            return self.getTypedRuleContext(HypothesisParser.SValueContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sBooleanOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSBooleanOperand" ):
                listener.enterSBooleanOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSBooleanOperand" ):
                listener.exitSBooleanOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSBooleanOperand" ):
                return visitor.visitSBooleanOperand(self)
            else:
                return visitor.visitChildren(self)




    def sBooleanOperand(self):

        localctx = HypothesisParser.SBooleanOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_sBooleanOperand)
        try:
            self.state = 185
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 183
                self.sValue()
                pass
            elif token in [HypothesisParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 184
                self.sProperty()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SBooleanOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sAnd(self):
            return self.getTypedRuleContext(HypothesisParser.SAndContext,0)


        def sOr(self):
            return self.getTypedRuleContext(HypothesisParser.SOrContext,0)


        def sNot(self):
            return self.getTypedRuleContext(HypothesisParser.SNotContext,0)


        def sEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SEqualsContext,0)


        def sNotEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SNotEqualsContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sBooleanOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSBooleanOperator" ):
                listener.enterSBooleanOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSBooleanOperator" ):
                listener.exitSBooleanOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSBooleanOperator" ):
                return visitor.visitSBooleanOperator(self)
            else:
                return visitor.visitChildren(self)




    def sBooleanOperator(self):

        localctx = HypothesisParser.SBooleanOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_sBooleanOperator)
        try:
            self.state = 192
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.AND]:
                self.enterOuterAlt(localctx, 1)
                self.state = 187
                self.sAnd()
                pass
            elif token in [HypothesisParser.OR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 188
                self.sOr()
                pass
            elif token in [HypothesisParser.NOT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 189
                self.sNot()
                pass
            elif token in [HypothesisParser.EQ, HypothesisParser.STRICT_EQ]:
                self.enterOuterAlt(localctx, 4)
                self.state = 190
                self.sEquals()
                pass
            elif token in [HypothesisParser.NEQ, HypothesisParser.STRICT_NEQ]:
                self.enterOuterAlt(localctx, 5)
                self.state = 191
                self.sNotEquals()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SBooleanExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sBooleanOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SBooleanOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SBooleanOperandContext,i)


        def sBooleanTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SBooleanTermContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SBooleanTermContext,i)


        def sBooleanOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SBooleanOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SBooleanOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sBooleanExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSBooleanExpression" ):
                listener.enterSBooleanExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSBooleanExpression" ):
                listener.exitSBooleanExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSBooleanExpression" ):
                return visitor.visitSBooleanExpression(self)
            else:
                return visitor.visitChildren(self)




    def sBooleanExpression(self):

        localctx = HypothesisParser.SBooleanExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_sBooleanExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 194
                self.sBooleanOperand()
                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 195
                self.sBooleanTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 205
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.AND) | (1 << HypothesisParser.OR) | (1 << HypothesisParser.NOT) | (1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ))) != 0):
                self.state = 198
                self.sBooleanOperator()
                self.state = 201
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                    self.state = 199
                    self.sBooleanOperand()
                    pass
                elif token in [HypothesisParser.ROUND_LEFT]:
                    self.state = 200
                    self.sBooleanTerm()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 207
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SBooleanTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND_LEFT(self):
            return self.getToken(HypothesisParser.ROUND_LEFT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(HypothesisParser.ROUND_RIGHT, 0)

        def sBooleanTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SBooleanTermContext,0)


        def sBooleanOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SBooleanOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SBooleanOperandContext,i)


        def sBooleanOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SBooleanOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SBooleanOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sBooleanTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSBooleanTerm" ):
                listener.enterSBooleanTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSBooleanTerm" ):
                listener.exitSBooleanTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSBooleanTerm" ):
                return visitor.visitSBooleanTerm(self)
            else:
                return visitor.visitChildren(self)




    def sBooleanTerm(self):

        localctx = HypothesisParser.SBooleanTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_sBooleanTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(HypothesisParser.ROUND_LEFT)
            self.state = 218
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 209
                self.sBooleanOperand()
                self.state = 213 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 210
                    self.sBooleanOperator()
                    self.state = 211
                    self.sBooleanOperand()
                    self.state = 215 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.AND) | (1 << HypothesisParser.OR) | (1 << HypothesisParser.NOT) | (1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ))) != 0)):
                        break

                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 217
                self.sBooleanTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 220
            self.match(HypothesisParser.ROUND_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNumberOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sNumber(self):
            return self.getTypedRuleContext(HypothesisParser.SNumberContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sNumberOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNumberOperand" ):
                listener.enterSNumberOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNumberOperand" ):
                listener.exitSNumberOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNumberOperand" ):
                return visitor.visitSNumberOperand(self)
            else:
                return visitor.visitChildren(self)




    def sNumberOperand(self):

        localctx = HypothesisParser.SNumberOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_sNumberOperand)
        try:
            self.state = 224
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.DIGITS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 222
                self.sNumber()
                pass
            elif token in [HypothesisParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 223
                self.sProperty()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNumberOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SEqualsContext,0)


        def sNotEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SNotEqualsContext,0)


        def sLowerThan(self):
            return self.getTypedRuleContext(HypothesisParser.SLowerThanContext,0)


        def sLowerEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SLowerEqualsContext,0)


        def sGreaterThan(self):
            return self.getTypedRuleContext(HypothesisParser.SGreaterThanContext,0)


        def sGreaterEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SGreaterEqualsContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sNumberOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNumberOperator" ):
                listener.enterSNumberOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNumberOperator" ):
                listener.exitSNumberOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNumberOperator" ):
                return visitor.visitSNumberOperator(self)
            else:
                return visitor.visitChildren(self)




    def sNumberOperator(self):

        localctx = HypothesisParser.SNumberOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_sNumberOperator)
        try:
            self.state = 232
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.EQ, HypothesisParser.STRICT_EQ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 226
                self.sEquals()
                pass
            elif token in [HypothesisParser.NEQ, HypothesisParser.STRICT_NEQ]:
                self.enterOuterAlt(localctx, 2)
                self.state = 227
                self.sNotEquals()
                pass
            elif token in [HypothesisParser.LT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 228
                self.sLowerThan()
                pass
            elif token in [HypothesisParser.LE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 229
                self.sLowerEquals()
                pass
            elif token in [HypothesisParser.GT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 230
                self.sGreaterThan()
                pass
            elif token in [HypothesisParser.GE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 231
                self.sGreaterEquals()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNumberExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sNumberOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberOperandContext,i)


        def sNumberTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberTermContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberTermContext,i)


        def sNumberOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sNumberExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNumberExpression" ):
                listener.enterSNumberExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNumberExpression" ):
                listener.exitSNumberExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNumberExpression" ):
                return visitor.visitSNumberExpression(self)
            else:
                return visitor.visitChildren(self)




    def sNumberExpression(self):

        localctx = HypothesisParser.SNumberExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_sNumberExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.IDENTIFIER, HypothesisParser.DIGITS]:
                self.state = 234
                self.sNumberOperand()
                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 235
                self.sNumberTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 243 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 238
                self.sNumberOperator()
                self.state = 241
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [HypothesisParser.IDENTIFIER, HypothesisParser.DIGITS]:
                    self.state = 239
                    self.sNumberOperand()
                    pass
                elif token in [HypothesisParser.ROUND_LEFT]:
                    self.state = 240
                    self.sNumberTerm()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 245 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ) | (1 << HypothesisParser.LT) | (1 << HypothesisParser.LE) | (1 << HypothesisParser.GT) | (1 << HypothesisParser.GE))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNumberTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND_LEFT(self):
            return self.getToken(HypothesisParser.ROUND_LEFT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(HypothesisParser.ROUND_RIGHT, 0)

        def sNumberTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SNumberTermContext,0)


        def sNumberOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberOperandContext,i)


        def sNumberOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sNumberTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNumberTerm" ):
                listener.enterSNumberTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNumberTerm" ):
                listener.exitSNumberTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNumberTerm" ):
                return visitor.visitSNumberTerm(self)
            else:
                return visitor.visitChildren(self)




    def sNumberTerm(self):

        localctx = HypothesisParser.SNumberTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_sNumberTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            self.match(HypothesisParser.ROUND_LEFT)
            self.state = 257
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.IDENTIFIER, HypothesisParser.DIGITS]:
                self.state = 248
                self.sNumberOperand()
                self.state = 252 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 249
                    self.sNumberOperator()
                    self.state = 250
                    self.sNumberOperand()
                    self.state = 254 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ) | (1 << HypothesisParser.LT) | (1 << HypothesisParser.LE) | (1 << HypothesisParser.GT) | (1 << HypothesisParser.GE))) != 0)):
                        break

                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 256
                self.sNumberTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 259
            self.match(HypothesisParser.ROUND_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SStringOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sStringOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSStringOperand" ):
                listener.enterSStringOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSStringOperand" ):
                listener.exitSStringOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSStringOperand" ):
                return visitor.visitSStringOperand(self)
            else:
                return visitor.visitChildren(self)




    def sStringOperand(self):

        localctx = HypothesisParser.SStringOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_sStringOperand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self.sString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SStringOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SEqualsContext,0)


        def sNotEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SNotEqualsContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sStringOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSStringOperator" ):
                listener.enterSStringOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSStringOperator" ):
                listener.exitSStringOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSStringOperator" ):
                return visitor.visitSStringOperator(self)
            else:
                return visitor.visitChildren(self)




    def sStringOperator(self):

        localctx = HypothesisParser.SStringOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_sStringOperator)
        try:
            self.state = 265
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.EQ, HypothesisParser.STRICT_EQ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 263
                self.sEquals()
                pass
            elif token in [HypothesisParser.NEQ, HypothesisParser.STRICT_NEQ]:
                self.enterOuterAlt(localctx, 2)
                self.state = 264
                self.sNotEquals()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SStringExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sStringOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringOperandContext,i)


        def sStringTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringTermContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringTermContext,i)


        def sStringOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sStringExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSStringExpression" ):
                listener.enterSStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSStringExpression" ):
                listener.exitSStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSStringExpression" ):
                return visitor.visitSStringExpression(self)
            else:
                return visitor.visitChildren(self)




    def sStringExpression(self):

        localctx = HypothesisParser.SStringExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_sStringExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.CHARS]:
                self.state = 267
                self.sStringOperand()
                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 268
                self.sStringTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 276 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 271
                self.sStringOperator()
                self.state = 274
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [HypothesisParser.CHARS]:
                    self.state = 272
                    self.sStringOperand()
                    pass
                elif token in [HypothesisParser.ROUND_LEFT]:
                    self.state = 273
                    self.sStringTerm()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 278 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SStringTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND_LEFT(self):
            return self.getToken(HypothesisParser.ROUND_LEFT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(HypothesisParser.ROUND_RIGHT, 0)

        def sStringTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SStringTermContext,0)


        def sStringOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringOperandContext,i)


        def sStringOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sStringTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSStringTerm" ):
                listener.enterSStringTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSStringTerm" ):
                listener.exitSStringTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSStringTerm" ):
                return visitor.visitSStringTerm(self)
            else:
                return visitor.visitChildren(self)




    def sStringTerm(self):

        localctx = HypothesisParser.SStringTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_sStringTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 280
            self.match(HypothesisParser.ROUND_LEFT)
            self.state = 290
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.CHARS]:
                self.state = 281
                self.sStringOperand()
                self.state = 285 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 282
                    self.sStringOperator()
                    self.state = 283
                    self.sStringOperand()
                    self.state = 287 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ))) != 0)):
                        break

                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 289
                self.sStringTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 292
            self.match(HypothesisParser.ROUND_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SConcatOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sConcatOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSConcatOperand" ):
                listener.enterSConcatOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSConcatOperand" ):
                listener.exitSConcatOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSConcatOperand" ):
                return visitor.visitSConcatOperand(self)
            else:
                return visitor.visitChildren(self)




    def sConcatOperand(self):

        localctx = HypothesisParser.SConcatOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_sConcatOperand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 294
            self.sString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SConcatExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sConcatBoth(self):
            return self.getTypedRuleContext(HypothesisParser.SConcatBothContext,0)


        def sConcatLeft(self):
            return self.getTypedRuleContext(HypothesisParser.SConcatLeftContext,0)


        def sConcatRight(self):
            return self.getTypedRuleContext(HypothesisParser.SConcatRightContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sConcatExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSConcatExpression" ):
                listener.enterSConcatExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSConcatExpression" ):
                listener.exitSConcatExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSConcatExpression" ):
                return visitor.visitSConcatExpression(self)
            else:
                return visitor.visitChildren(self)




    def sConcatExpression(self):

        localctx = HypothesisParser.SConcatExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_sConcatExpression)
        try:
            self.state = 299
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 296
                self.sConcatBoth()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 297
                self.sConcatLeft()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 298
                self.sConcatRight()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SConcatLeftContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def sPlus(self):
            return self.getTypedRuleContext(HypothesisParser.SPlusContext,0)


        def sValue(self):
            return self.getTypedRuleContext(HypothesisParser.SValueContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sConcatLeft

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSConcatLeft" ):
                listener.enterSConcatLeft(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSConcatLeft" ):
                listener.exitSConcatLeft(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSConcatLeft" ):
                return visitor.visitSConcatLeft(self)
            else:
                return visitor.visitChildren(self)




    def sConcatLeft(self):

        localctx = HypothesisParser.SConcatLeftContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_sConcatLeft)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 301
            self.sString()
            self.state = 302
            self.sPlus()
            self.state = 305
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 303
                self.sValue()
                pass
            elif token in [HypothesisParser.IDENTIFIER]:
                self.state = 304
                self.sProperty()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SConcatRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sPlus(self):
            return self.getTypedRuleContext(HypothesisParser.SPlusContext,0)


        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def sValue(self):
            return self.getTypedRuleContext(HypothesisParser.SValueContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sConcatRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSConcatRight" ):
                listener.enterSConcatRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSConcatRight" ):
                listener.exitSConcatRight(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSConcatRight" ):
                return visitor.visitSConcatRight(self)
            else:
                return visitor.visitChildren(self)




    def sConcatRight(self):

        localctx = HypothesisParser.SConcatRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_sConcatRight)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 307
                self.sValue()
                pass
            elif token in [HypothesisParser.IDENTIFIER]:
                self.state = 308
                self.sProperty()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 311
            self.sPlus()
            self.state = 312
            self.sString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SConcatBothContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringContext,i)


        def sPlus(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SPlusContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SPlusContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sConcatBoth

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSConcatBoth" ):
                listener.enterSConcatBoth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSConcatBoth" ):
                listener.exitSConcatBoth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSConcatBoth" ):
                return visitor.visitSConcatBoth(self)
            else:
                return visitor.visitChildren(self)




    def sConcatBoth(self):

        localctx = HypothesisParser.SConcatBothContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_sConcatBoth)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 314
            self.sString()
            self.state = 318 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 315
                self.sPlus()
                self.state = 316
                self.sString()
                self.state = 320 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==HypothesisParser.PLUS):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class STypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(HypothesisParser.STRING, 0)

        def NUMBER(self):
            return self.getToken(HypothesisParser.NUMBER, 0)

        def BOOLEAN(self):
            return self.getToken(HypothesisParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSType" ):
                listener.enterSType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSType" ):
                listener.exitSType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSType" ):
                return visitor.visitSType(self)
            else:
                return visitor.visitChildren(self)




    def sType(self):

        localctx = HypothesisParser.STypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_sType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.STRING) | (1 << HypothesisParser.NUMBER) | (1 << HypothesisParser.BOOLEAN))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SPropertyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(HypothesisParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sProperty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSProperty" ):
                listener.enterSProperty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSProperty" ):
                listener.exitSProperty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSProperty" ):
                return visitor.visitSProperty(self)
            else:
                return visitor.visitChildren(self)




    def sProperty(self):

        localctx = HypothesisParser.SPropertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_sProperty)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(HypothesisParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SPropertyAwareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sPropertyAware

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSPropertyAware" ):
                listener.enterSPropertyAware(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSPropertyAware" ):
                listener.exitSPropertyAware(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSPropertyAware" ):
                return visitor.visitSPropertyAware(self)
            else:
                return visitor.visitChildren(self)




    def sPropertyAware(self):

        localctx = HypothesisParser.SPropertyAwareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_sPropertyAware)
        try:
            self.state = 328
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.CHARS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 326
                self.sString()
                pass
            elif token in [HypothesisParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 327
                self.sProperty()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SPropertyAccessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sPropertyAware(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyAwareContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.DOT)
            else:
                return self.getToken(HypothesisParser.DOT, i)

        def sProperty(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SPropertyContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SPropertyContext,i)


        def BRACKET_LEFT(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.BRACKET_LEFT)
            else:
                return self.getToken(HypothesisParser.BRACKET_LEFT, i)

        def BRACKET_RIGHT(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.BRACKET_RIGHT)
            else:
                return self.getToken(HypothesisParser.BRACKET_RIGHT, i)

        def sNumber(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberContext,i)


        def sString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sPropertyAccess

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSPropertyAccess" ):
                listener.enterSPropertyAccess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSPropertyAccess" ):
                listener.exitSPropertyAccess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSPropertyAccess" ):
                return visitor.visitSPropertyAccess(self)
            else:
                return visitor.visitChildren(self)




    def sPropertyAccess(self):

        localctx = HypothesisParser.SPropertyAccessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_sPropertyAccess)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 330
            self.sPropertyAware()
            self.state = 340 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 340
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [HypothesisParser.DOT]:
                    self.state = 331
                    self.match(HypothesisParser.DOT)
                    self.state = 332
                    self.sProperty()
                    pass
                elif token in [HypothesisParser.BRACKET_LEFT]:
                    self.state = 333
                    self.match(HypothesisParser.BRACKET_LEFT)
                    self.state = 336
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [HypothesisParser.DIGITS]:
                        self.state = 334
                        self.sNumber()
                        pass
                    elif token in [HypothesisParser.CHARS]:
                        self.state = 335
                        self.sString()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 338
                    self.match(HypothesisParser.BRACKET_RIGHT)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 342 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==HypothesisParser.DOT or _la==HypothesisParser.BRACKET_LEFT):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SStringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHARS(self):
            return self.getToken(HypothesisParser.CHARS, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sString

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSString" ):
                listener.enterSString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSString" ):
                listener.exitSString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSString" ):
                return visitor.visitSString(self)
            else:
                return visitor.visitChildren(self)




    def sString(self):

        localctx = HypothesisParser.SStringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_sString)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 344
            self.match(HypothesisParser.CHARS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGITS(self):
            return self.getToken(HypothesisParser.DIGITS, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sNumber

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNumber" ):
                listener.enterSNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNumber" ):
                listener.exitSNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNumber" ):
                return visitor.visitSNumber(self)
            else:
                return visitor.visitChildren(self)




    def sNumber(self):

        localctx = HypothesisParser.SNumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_sNumber)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 346
            self.match(HypothesisParser.DIGITS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SBooleanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(HypothesisParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(HypothesisParser.FALSE, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sBoolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSBoolean" ):
                listener.enterSBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSBoolean" ):
                listener.exitSBoolean(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSBoolean" ):
                return visitor.visitSBoolean(self)
            else:
                return visitor.visitChildren(self)




    def sBoolean(self):

        localctx = HypothesisParser.SBooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_sBoolean)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 348
            _la = self._input.LA(1)
            if not(_la==HypothesisParser.TRUE or _la==HypothesisParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SArrayContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BRACKET_LEFT(self):
            return self.getToken(HypothesisParser.BRACKET_LEFT, 0)

        def BRACKET_RIGHT(self):
            return self.getToken(HypothesisParser.BRACKET_RIGHT, 0)

        def sValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SValueContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SValueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.COMMA)
            else:
                return self.getToken(HypothesisParser.COMMA, i)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sArray

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSArray" ):
                listener.enterSArray(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSArray" ):
                listener.exitSArray(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSArray" ):
                return visitor.visitSArray(self)
            else:
                return visitor.visitChildren(self)




    def sArray(self):

        localctx = HypothesisParser.SArrayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_sArray)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350
            self.match(HypothesisParser.BRACKET_LEFT)
            self.state = 359
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.TRUE) | (1 << HypothesisParser.FALSE) | (1 << HypothesisParser.CURLY_LEFT) | (1 << HypothesisParser.BRACKET_LEFT) | (1 << HypothesisParser.CHARS) | (1 << HypothesisParser.DIGITS))) != 0):
                self.state = 351
                self.sValue()
                self.state = 356
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==HypothesisParser.COMMA:
                    self.state = 352
                    self.match(HypothesisParser.COMMA)
                    self.state = 353
                    self.sValue()
                    self.state = 358
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 361
            self.match(HypothesisParser.BRACKET_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SMapContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CURLY_LEFT(self):
            return self.getToken(HypothesisParser.CURLY_LEFT, 0)

        def CURLY_RIGHT(self):
            return self.getToken(HypothesisParser.CURLY_RIGHT, 0)

        def sString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringContext,i)


        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.COLON)
            else:
                return self.getToken(HypothesisParser.COLON, i)

        def sValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SValueContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SValueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.COMMA)
            else:
                return self.getToken(HypothesisParser.COMMA, i)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sMap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSMap" ):
                listener.enterSMap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSMap" ):
                listener.exitSMap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSMap" ):
                return visitor.visitSMap(self)
            else:
                return visitor.visitChildren(self)




    def sMap(self):

        localctx = HypothesisParser.SMapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_sMap)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            self.match(HypothesisParser.CURLY_LEFT)
            self.state = 377
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==HypothesisParser.CHARS:
                self.state = 364
                self.sString()
                self.state = 365
                self.match(HypothesisParser.COLON)
                self.state = 366
                self.sValue()
                self.state = 374
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==HypothesisParser.COMMA:
                    self.state = 367
                    self.match(HypothesisParser.COMMA)
                    self.state = 368
                    self.sString()
                    self.state = 369
                    self.match(HypothesisParser.COLON)
                    self.state = 370
                    self.sValue()
                    self.state = 376
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 379
            self.match(HypothesisParser.CURLY_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





