# Generated from Hypothesis.g4 by ANTLR 4.9.2
# encoding: utf-8
import sys
from io import StringIO

from antlr4 import *

if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\66")
        buf.write("\u0183\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\3\2\3\2\3\2\3\3\3\3\3\3\5\3i")
        buf.write("\n\3\3\4\3\4\3\4\3\4\3\4\5\4p\n\4\3\5\3\5\3\5\3\5\3\5")
        buf.write("\5\5w\n\5\3\6\3\6\5\6{\n\6\3\7\3\7\3\7\3\7\3\7\5\7\u0082")
        buf.write("\n\7\3\b\3\b\3\t\3\t\3\n\3\n\3\13\3\13\3\f\3\f\3\r\3\r")
        buf.write("\3\16\3\16\3\17\3\17\3\20\3\20\3\21\3\21\3\22\3\22\3\23")
        buf.write("\3\23\3\24\3\24\3\25\3\25\3\26\3\26\5\26\u00a2\n\26\3")
        buf.write("\26\3\26\3\26\5\26\u00a7\n\26\6\26\u00a9\n\26\r\26\16")
        buf.write("\26\u00aa\3\27\3\27\3\27\3\27\3\27\6\27\u00b2\n\27\r\27")
        buf.write("\16\27\u00b3\3\27\5\27\u00b7\n\27\3\27\3\27\3\30\3\30")
        buf.write("\3\30\5\30\u00be\n\30\3\31\3\31\3\31\3\31\3\31\5\31\u00c5")
        buf.write("\n\31\3\32\3\32\5\32\u00c9\n\32\3\32\3\32\3\32\5\32\u00ce")
        buf.write("\n\32\7\32\u00d0\n\32\f\32\16\32\u00d3\13\32\3\33\3\33")
        buf.write("\3\33\3\33\3\33\6\33\u00da\n\33\r\33\16\33\u00db\3\33")
        buf.write("\5\33\u00df\n\33\3\33\3\33\3\34\3\34\3\34\5\34\u00e6\n")
        buf.write("\34\3\35\3\35\3\35\3\35\3\35\3\35\5\35\u00ee\n\35\3\36")
        buf.write("\3\36\5\36\u00f2\n\36\3\36\3\36\3\36\5\36\u00f7\n\36\6")
        buf.write("\36\u00f9\n\36\r\36\16\36\u00fa\3\37\3\37\3\37\3\37\3")
        buf.write("\37\6\37\u0102\n\37\r\37\16\37\u0103\3\37\5\37\u0107\n")
        buf.write("\37\3\37\3\37\3 \3 \3!\3!\5!\u010f\n!\3\"\3\"\5\"\u0113")
        buf.write("\n\"\3\"\3\"\3\"\5\"\u0118\n\"\6\"\u011a\n\"\r\"\16\"")
        buf.write("\u011b\3#\3#\3#\3#\3#\6#\u0123\n#\r#\16#\u0124\3#\5#\u0128")
        buf.write("\n#\3#\3#\3$\3$\3%\3%\3%\5%\u0131\n%\3&\3&\3&\3&\5&\u0137")
        buf.write("\n&\3\'\3\'\5\'\u013b\n\'\3\'\3\'\3\'\3(\3(\3(\3(\6(\u0144")
        buf.write("\n(\r(\16(\u0145\3)\3)\3*\3*\3+\3+\5+\u014e\n+\3,\3,\3")
        buf.write(",\3,\3,\3,\5,\u0156\n,\3,\3,\6,\u015a\n,\r,\16,\u015b")
        buf.write("\3-\3-\3.\3.\3/\3/\3\60\3\60\3\60\3\60\7\60\u0168\n\60")
        buf.write("\f\60\16\60\u016b\13\60\5\60\u016d\n\60\3\60\3\60\3\61")
        buf.write("\3\61\3\61\3\61\3\61\3\61\3\61\3\61\3\61\7\61\u017a\n")
        buf.write("\61\f\61\16\61\u017d\13\61\5\61\u017f\n\61\3\61\3\61\3")
        buf.write("\61\2\2\62\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$")
        buf.write("&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`\2\6\3\2\27\30")
        buf.write("\3\2\31\32\3\2#%\3\2\3\4\2\u0190\2b\3\2\2\2\4h\3\2\2\2")
        buf.write("\6o\3\2\2\2\bv\3\2\2\2\nz\3\2\2\2\f\u0081\3\2\2\2\16\u0083")
        buf.write("\3\2\2\2\20\u0085\3\2\2\2\22\u0087\3\2\2\2\24\u0089\3")
        buf.write("\2\2\2\26\u008b\3\2\2\2\30\u008d\3\2\2\2\32\u008f\3\2")
        buf.write("\2\2\34\u0091\3\2\2\2\36\u0093\3\2\2\2 \u0095\3\2\2\2")
        buf.write("\"\u0097\3\2\2\2$\u0099\3\2\2\2&\u009b\3\2\2\2(\u009d")
        buf.write("\3\2\2\2*\u00a1\3\2\2\2,\u00ac\3\2\2\2.\u00bd\3\2\2\2")
        buf.write("\60\u00c4\3\2\2\2\62\u00c8\3\2\2\2\64\u00d4\3\2\2\2\66")
        buf.write("\u00e5\3\2\2\28\u00ed\3\2\2\2:\u00f1\3\2\2\2<\u00fc\3")
        buf.write("\2\2\2>\u010a\3\2\2\2@\u010e\3\2\2\2B\u0112\3\2\2\2D\u011d")
        buf.write("\3\2\2\2F\u012b\3\2\2\2H\u0130\3\2\2\2J\u0132\3\2\2\2")
        buf.write("L\u013a\3\2\2\2N\u013f\3\2\2\2P\u0147\3\2\2\2R\u0149\3")
        buf.write("\2\2\2T\u014d\3\2\2\2V\u014f\3\2\2\2X\u015d\3\2\2\2Z\u015f")
        buf.write("\3\2\2\2\\\u0161\3\2\2\2^\u0163\3\2\2\2`\u0170\3\2\2\2")
        buf.write("bc\5\b\5\2cd\7\2\2\3d\3\3\2\2\2ei\5Z.\2fi\5R*\2gi\5V,")
        buf.write("\2he\3\2\2\2hf\3\2\2\2hg\3\2\2\2i\5\3\2\2\2jp\5\16\b\2")
        buf.write("kp\5\20\t\2lp\5\22\n\2mp\5\24\13\2np\5\26\f\2oj\3\2\2")
        buf.write("\2ok\3\2\2\2ol\3\2\2\2om\3\2\2\2on\3\2\2\2p\7\3\2\2\2")
        buf.write("qw\5H%\2rw\5*\26\2sw\5\62\32\2tw\5:\36\2uw\5B\"\2vq\3")
        buf.write("\2\2\2vr\3\2\2\2vs\3\2\2\2vt\3\2\2\2vu\3\2\2\2w\t\3\2")
        buf.write("\2\2x{\5,\27\2y{\5\64\33\2zx\3\2\2\2zy\3\2\2\2{\13\3\2")
        buf.write("\2\2|\u0082\5Z.\2}\u0082\5\\/\2~\u0082\5X-\2\177\u0082")
        buf.write("\5^\60\2\u0080\u0082\5`\61\2\u0081|\3\2\2\2\u0081}\3\2")
        buf.write("\2\2\u0081~\3\2\2\2\u0081\177\3\2\2\2\u0081\u0080\3\2")
        buf.write("\2\2\u0082\r\3\2\2\2\u0083\u0084\7\t\2\2\u0084\17\3\2")
        buf.write("\2\2\u0085\u0086\7\n\2\2\u0086\21\3\2\2\2\u0087\u0088")
        buf.write("\7\13\2\2\u0088\23\3\2\2\2\u0089\u008a\7\f\2\2\u008a\25")
        buf.write("\3\2\2\2\u008b\u008c\7\r\2\2\u008c\27\3\2\2\2\u008d\u008e")
        buf.write("\7\24\2\2\u008e\31\3\2\2\2\u008f\u0090\7\25\2\2\u0090")
        buf.write("\33\3\2\2\2\u0091\u0092\7\26\2\2\u0092\35\3\2\2\2\u0093")
        buf.write("\u0094\t\2\2\2\u0094\37\3\2\2\2\u0095\u0096\t\3\2\2\u0096")
        buf.write("!\3\2\2\2\u0097\u0098\7\33\2\2\u0098#\3\2\2\2\u0099\u009a")
        buf.write("\7\34\2\2\u009a%\3\2\2\2\u009b\u009c\7\35\2\2\u009c\'")
        buf.write("\3\2\2\2\u009d\u009e\7\36\2\2\u009e)\3\2\2\2\u009f\u00a2")
        buf.write("\5\4\3\2\u00a0\u00a2\5,\27\2\u00a1\u009f\3\2\2\2\u00a1")
        buf.write("\u00a0\3\2\2\2\u00a2\u00a8\3\2\2\2\u00a3\u00a6\5\6\4\2")
        buf.write("\u00a4\u00a7\5\4\3\2\u00a5\u00a7\5,\27\2\u00a6\u00a4\3")
        buf.write("\2\2\2\u00a6\u00a5\3\2\2\2\u00a7\u00a9\3\2\2\2\u00a8\u00a3")
        buf.write("\3\2\2\2\u00a9\u00aa\3\2\2\2\u00aa\u00a8\3\2\2\2\u00aa")
        buf.write("\u00ab\3\2\2\2\u00ab+\3\2\2\2\u00ac\u00b6\7\16\2\2\u00ad")
        buf.write("\u00b1\5\4\3\2\u00ae\u00af\5\6\4\2\u00af\u00b0\5\4\3\2")
        buf.write("\u00b0\u00b2\3\2\2\2\u00b1\u00ae\3\2\2\2\u00b2\u00b3\3")
        buf.write("\2\2\2\u00b3\u00b1\3\2\2\2\u00b3\u00b4\3\2\2\2\u00b4\u00b7")
        buf.write("\3\2\2\2\u00b5\u00b7\5,\27\2\u00b6\u00ad\3\2\2\2\u00b6")
        buf.write("\u00b5\3\2\2\2\u00b7\u00b8\3\2\2\2\u00b8\u00b9\7\17\2")
        buf.write("\2\u00b9-\3\2\2\2\u00ba\u00be\5\f\7\2\u00bb\u00be\5R*")
        buf.write("\2\u00bc\u00be\5V,\2\u00bd\u00ba\3\2\2\2\u00bd\u00bb\3")
        buf.write("\2\2\2\u00bd\u00bc\3\2\2\2\u00be/\3\2\2\2\u00bf\u00c5")
        buf.write("\5\30\r\2\u00c0\u00c5\5\32\16\2\u00c1\u00c5\5\34\17\2")
        buf.write("\u00c2\u00c5\5\36\20\2\u00c3\u00c5\5 \21\2\u00c4\u00bf")
        buf.write("\3\2\2\2\u00c4\u00c0\3\2\2\2\u00c4\u00c1\3\2\2\2\u00c4")
        buf.write("\u00c2\3\2\2\2\u00c4\u00c3\3\2\2\2\u00c5\61\3\2\2\2\u00c6")
        buf.write("\u00c9\5.\30\2\u00c7\u00c9\5\64\33\2\u00c8\u00c6\3\2\2")
        buf.write("\2\u00c8\u00c7\3\2\2\2\u00c9\u00d1\3\2\2\2\u00ca\u00cd")
        buf.write("\5\60\31\2\u00cb\u00ce\5.\30\2\u00cc\u00ce\5\64\33\2\u00cd")
        buf.write("\u00cb\3\2\2\2\u00cd\u00cc\3\2\2\2\u00ce\u00d0\3\2\2\2")
        buf.write("\u00cf\u00ca\3\2\2\2\u00d0\u00d3\3\2\2\2\u00d1\u00cf\3")
        buf.write("\2\2\2\u00d1\u00d2\3\2\2\2\u00d2\63\3\2\2\2\u00d3\u00d1")
        buf.write("\3\2\2\2\u00d4\u00de\7\16\2\2\u00d5\u00d9\5.\30\2\u00d6")
        buf.write("\u00d7\5\60\31\2\u00d7\u00d8\5.\30\2\u00d8\u00da\3\2\2")
        buf.write("\2\u00d9\u00d6\3\2\2\2\u00da\u00db\3\2\2\2\u00db\u00d9")
        buf.write("\3\2\2\2\u00db\u00dc\3\2\2\2\u00dc\u00df\3\2\2\2\u00dd")
        buf.write("\u00df\5\64\33\2\u00de\u00d5\3\2\2\2\u00de\u00dd\3\2\2")
        buf.write("\2\u00df\u00e0\3\2\2\2\u00e0\u00e1\7\17\2\2\u00e1\65\3")
        buf.write("\2\2\2\u00e2\u00e6\5Z.\2\u00e3\u00e6\5R*\2\u00e4\u00e6")
        buf.write("\5V,\2\u00e5\u00e2\3\2\2\2\u00e5\u00e3\3\2\2\2\u00e5\u00e4")
        buf.write("\3\2\2\2\u00e6\67\3\2\2\2\u00e7\u00ee\5\36\20\2\u00e8")
        buf.write("\u00ee\5 \21\2\u00e9\u00ee\5\"\22\2\u00ea\u00ee\5$\23")
        buf.write("\2\u00eb\u00ee\5&\24\2\u00ec\u00ee\5(\25\2\u00ed\u00e7")
        buf.write("\3\2\2\2\u00ed\u00e8\3\2\2\2\u00ed\u00e9\3\2\2\2\u00ed")
        buf.write("\u00ea\3\2\2\2\u00ed\u00eb\3\2\2\2\u00ed\u00ec\3\2\2\2")
        buf.write("\u00ee9\3\2\2\2\u00ef\u00f2\5\66\34\2\u00f0\u00f2\5<\37")
        buf.write("\2\u00f1\u00ef\3\2\2\2\u00f1\u00f0\3\2\2\2\u00f2\u00f8")
        buf.write("\3\2\2\2\u00f3\u00f6\58\35\2\u00f4\u00f7\5\66\34\2\u00f5")
        buf.write("\u00f7\5<\37\2\u00f6\u00f4\3\2\2\2\u00f6\u00f5\3\2\2\2")
        buf.write("\u00f7\u00f9\3\2\2\2\u00f8\u00f3\3\2\2\2\u00f9\u00fa\3")
        buf.write("\2\2\2\u00fa\u00f8\3\2\2\2\u00fa\u00fb\3\2\2\2\u00fb;")
        buf.write("\3\2\2\2\u00fc\u0106\7\16\2\2\u00fd\u0101\5\66\34\2\u00fe")
        buf.write("\u00ff\58\35\2\u00ff\u0100\5\66\34\2\u0100\u0102\3\2\2")
        buf.write("\2\u0101\u00fe\3\2\2\2\u0102\u0103\3\2\2\2\u0103\u0101")
        buf.write("\3\2\2\2\u0103\u0104\3\2\2\2\u0104\u0107\3\2\2\2\u0105")
        buf.write("\u0107\5<\37\2\u0106\u00fd\3\2\2\2\u0106\u0105\3\2\2\2")
        buf.write("\u0107\u0108\3\2\2\2\u0108\u0109\7\17\2\2\u0109=\3\2\2")
        buf.write("\2\u010a\u010b\5X-\2\u010b?\3\2\2\2\u010c\u010f\5\36\20")
        buf.write("\2\u010d\u010f\5 \21\2\u010e\u010c\3\2\2\2\u010e\u010d")
        buf.write("\3\2\2\2\u010fA\3\2\2\2\u0110\u0113\5> \2\u0111\u0113")
        buf.write("\5D#\2\u0112\u0110\3\2\2\2\u0112\u0111\3\2\2\2\u0113\u0119")
        buf.write("\3\2\2\2\u0114\u0117\5@!\2\u0115\u0118\5> \2\u0116\u0118")
        buf.write("\5D#\2\u0117\u0115\3\2\2\2\u0117\u0116\3\2\2\2\u0118\u011a")
        buf.write("\3\2\2\2\u0119\u0114\3\2\2\2\u011a\u011b\3\2\2\2\u011b")
        buf.write("\u0119\3\2\2\2\u011b\u011c\3\2\2\2\u011cC\3\2\2\2\u011d")
        buf.write("\u0127\7\16\2\2\u011e\u0122\5> \2\u011f\u0120\5@!\2\u0120")
        buf.write("\u0121\5> \2\u0121\u0123\3\2\2\2\u0122\u011f\3\2\2\2\u0123")
        buf.write("\u0124\3\2\2\2\u0124\u0122\3\2\2\2\u0124\u0125\3\2\2\2")
        buf.write("\u0125\u0128\3\2\2\2\u0126\u0128\5D#\2\u0127\u011e\3\2")
        buf.write("\2\2\u0127\u0126\3\2\2\2\u0128\u0129\3\2\2\2\u0129\u012a")
        buf.write("\7\17\2\2\u012aE\3\2\2\2\u012b\u012c\5X-\2\u012cG\3\2")
        buf.write("\2\2\u012d\u0131\5N(\2\u012e\u0131\5J&\2\u012f\u0131\5")
        buf.write("L\'\2\u0130\u012d\3\2\2\2\u0130\u012e\3\2\2\2\u0130\u012f")
        buf.write("\3\2\2\2\u0131I\3\2\2\2\u0132\u0133\5X-\2\u0133\u0136")
        buf.write("\5\16\b\2\u0134\u0137\5\f\7\2\u0135\u0137\5R*\2\u0136")
        buf.write("\u0134\3\2\2\2\u0136\u0135\3\2\2\2\u0137K\3\2\2\2\u0138")
        buf.write("\u013b\5\f\7\2\u0139\u013b\5R*\2\u013a\u0138\3\2\2\2\u013a")
        buf.write("\u0139\3\2\2\2\u013b\u013c\3\2\2\2\u013c\u013d\5\16\b")
        buf.write("\2\u013d\u013e\5X-\2\u013eM\3\2\2\2\u013f\u0143\5X-\2")
        buf.write("\u0140\u0141\5\16\b\2\u0141\u0142\5X-\2\u0142\u0144\3")
        buf.write("\2\2\2\u0143\u0140\3\2\2\2\u0144\u0145\3\2\2\2\u0145\u0143")
        buf.write("\3\2\2\2\u0145\u0146\3\2\2\2\u0146O\3\2\2\2\u0147\u0148")
        buf.write("\t\4\2\2\u0148Q\3\2\2\2\u0149\u014a\7\61\2\2\u014aS\3")
        buf.write("\2\2\2\u014b\u014e\5X-\2\u014c\u014e\5R*\2\u014d\u014b")
        buf.write("\3\2\2\2\u014d\u014c\3\2\2\2\u014eU\3\2\2\2\u014f\u0159")
        buf.write("\5T+\2\u0150\u0151\7\5\2\2\u0151\u015a\5R*\2\u0152\u0155")
        buf.write("\7\22\2\2\u0153\u0156\5Z.\2\u0154\u0156\5X-\2\u0155\u0153")
        buf.write("\3\2\2\2\u0155\u0154\3\2\2\2\u0156\u0157\3\2\2\2\u0157")
        buf.write("\u0158\7\23\2\2\u0158\u015a\3\2\2\2\u0159\u0150\3\2\2")
        buf.write("\2\u0159\u0152\3\2\2\2\u015a\u015b\3\2\2\2\u015b\u0159")
        buf.write("\3\2\2\2\u015b\u015c\3\2\2\2\u015cW\3\2\2\2\u015d\u015e")
        buf.write("\7\62\2\2\u015eY\3\2\2\2\u015f\u0160\7\63\2\2\u0160[\3")
        buf.write("\2\2\2\u0161\u0162\t\5\2\2\u0162]\3\2\2\2\u0163\u016c")
        buf.write("\7\22\2\2\u0164\u0169\5\f\7\2\u0165\u0166\7\7\2\2\u0166")
        buf.write("\u0168\5\f\7\2\u0167\u0165\3\2\2\2\u0168\u016b\3\2\2\2")
        buf.write("\u0169\u0167\3\2\2\2\u0169\u016a\3\2\2\2\u016a\u016d\3")
        buf.write("\2\2\2\u016b\u0169\3\2\2\2\u016c\u0164\3\2\2\2\u016c\u016d")
        buf.write("\3\2\2\2\u016d\u016e\3\2\2\2\u016e\u016f\7\23\2\2\u016f")
        buf.write("_\3\2\2\2\u0170\u017e\7\20\2\2\u0171\u0172\5X-\2\u0172")
        buf.write("\u0173\7\6\2\2\u0173\u017b\5\f\7\2\u0174\u0175\7\7\2\2")
        buf.write("\u0175\u0176\5X-\2\u0176\u0177\7\6\2\2\u0177\u0178\5\f")
        buf.write("\7\2\u0178\u017a\3\2\2\2\u0179\u0174\3\2\2\2\u017a\u017d")
        buf.write("\3\2\2\2\u017b\u0179\3\2\2\2\u017b\u017c\3\2\2\2\u017c")
        buf.write("\u017f\3\2\2\2\u017d\u017b\3\2\2\2\u017e\u0171\3\2\2\2")
        buf.write("\u017e\u017f\3\2\2\2\u017f\u0180\3\2\2\2\u0180\u0181\7")
        buf.write("\21\2\2\u0181a\3\2\2\2,hovz\u0081\u00a1\u00a6\u00aa\u00b3")
        buf.write("\u00b6\u00bd\u00c4\u00c8\u00cd\u00d1\u00db\u00de\u00e5")
        buf.write("\u00ed\u00f1\u00f6\u00fa\u0103\u0106\u010e\u0112\u0117")
        buf.write("\u011b\u0124\u0127\u0130\u0136\u013a\u0145\u014d\u0155")
        buf.write("\u0159\u015b\u0169\u016c\u017b\u017e")
        return buf.getvalue()


class HypothesisParser ( Parser ):

    grammarFileName = "Hypothesis.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'true'", "'false'", "'.'", "':'", "','", 
                     "';'", "'+'", "'-'", "'*'", "'/'", "'**'", "'('", "')'", 
                     "'{'", "'}'", "'['", "']'", "'&&'", "'||'", "'!'", 
                     "'=='", "'==='", "'!='", "'!=='", "'<'", "'<='", "'>'", 
                     "'>='", "'if'", "'else'", "'return'", "'function'", 
                     "'string'", "'number'", "'boolean'", "'=>'", "'while'", 
                     "'for'", "'in'", "'of'", "'const'", "'var'", "'let'", 
                     "'='", "'break'", "'continue'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "' '" ]

    symbolicNames = [ "<INVALID>", "TRUE", "FALSE", "DOT", "COLON", "COMMA", 
                      "SEMICOLON", "PLUS", "MINUS", "MUL", "DIV", "POWER", 
                      "ROUND_LEFT", "ROUND_RIGHT", "CURLY_LEFT", "CURLY_RIGHT", 
                      "BRACKET_LEFT", "BRACKET_RIGHT", "AND", "OR", "NOT", 
                      "EQ", "STRICT_EQ", "NEQ", "STRICT_NEQ", "LT", "LE", 
                      "GT", "GE", "IF", "ELSE", "RETURN", "FUNCTION", "STRING", 
                      "NUMBER", "BOOLEAN", "ARROW", "WHILE", "FOR", "IN", 
                      "OF", "CONST", "VAR", "LET", "EQUAL", "BREAK", "CONTINUE", 
                      "IDENTIFIER", "CHARS", "DIGITS", "WS", "LINE_COMMENT", 
                      "WHITESPACE" ]

    RULE_sAll = 0
    RULE_sOperand = 1
    RULE_sOperator = 2
    RULE_sExpression = 3
    RULE_sTerm = 4
    RULE_sValue = 5
    RULE_sPlus = 6
    RULE_sMinus = 7
    RULE_sMul = 8
    RULE_sDiv = 9
    RULE_sPower = 10
    RULE_sAnd = 11
    RULE_sOr = 12
    RULE_sNot = 13
    RULE_sEquals = 14
    RULE_sNotEquals = 15
    RULE_sLowerThan = 16
    RULE_sLowerEquals = 17
    RULE_sGreaterThan = 18
    RULE_sGreaterEquals = 19
    RULE_sArithmeticExpression = 20
    RULE_sArithmeticTerm = 21
    RULE_sBooleanOperand = 22
    RULE_sBooleanOperator = 23
    RULE_sBooleanExpression = 24
    RULE_sBooleanTerm = 25
    RULE_sNumberOperand = 26
    RULE_sNumberOperator = 27
    RULE_sNumberExpression = 28
    RULE_sNumberTerm = 29
    RULE_sStringOperand = 30
    RULE_sStringOperator = 31
    RULE_sStringExpression = 32
    RULE_sStringTerm = 33
    RULE_sConcatOperand = 34
    RULE_sConcatExpression = 35
    RULE_sConcatLeft = 36
    RULE_sConcatRight = 37
    RULE_sConcatBoth = 38
    RULE_sType = 39
    RULE_sProperty = 40
    RULE_sPropertyAware = 41
    RULE_sPropertyAccess = 42
    RULE_sString = 43
    RULE_sNumber = 44
    RULE_sBoolean = 45
    RULE_sArray = 46
    RULE_sMap = 47

    ruleNames =  [ "sAll", "sOperand", "sOperator", "sExpression", "sTerm", 
                   "sValue", "sPlus", "sMinus", "sMul", "sDiv", "sPower", 
                   "sAnd", "sOr", "sNot", "sEquals", "sNotEquals", "sLowerThan", 
                   "sLowerEquals", "sGreaterThan", "sGreaterEquals", "sArithmeticExpression", 
                   "sArithmeticTerm", "sBooleanOperand", "sBooleanOperator", 
                   "sBooleanExpression", "sBooleanTerm", "sNumberOperand", 
                   "sNumberOperator", "sNumberExpression", "sNumberTerm", 
                   "sStringOperand", "sStringOperator", "sStringExpression", 
                   "sStringTerm", "sConcatOperand", "sConcatExpression", 
                   "sConcatLeft", "sConcatRight", "sConcatBoth", "sType", 
                   "sProperty", "sPropertyAware", "sPropertyAccess", "sString", 
                   "sNumber", "sBoolean", "sArray", "sMap" ]

    EOF = Token.EOF
    TRUE=1
    FALSE=2
    DOT=3
    COLON=4
    COMMA=5
    SEMICOLON=6
    PLUS=7
    MINUS=8
    MUL=9
    DIV=10
    POWER=11
    ROUND_LEFT=12
    ROUND_RIGHT=13
    CURLY_LEFT=14
    CURLY_RIGHT=15
    BRACKET_LEFT=16
    BRACKET_RIGHT=17
    AND=18
    OR=19
    NOT=20
    EQ=21
    STRICT_EQ=22
    NEQ=23
    STRICT_NEQ=24
    LT=25
    LE=26
    GT=27
    GE=28
    IF=29
    ELSE=30
    RETURN=31
    FUNCTION=32
    STRING=33
    NUMBER=34
    BOOLEAN=35
    ARROW=36
    WHILE=37
    FOR=38
    IN=39
    OF=40
    CONST=41
    VAR=42
    LET=43
    EQUAL=44
    BREAK=45
    CONTINUE=46
    IDENTIFIER=47
    CHARS=48
    DIGITS=49
    WS=50
    LINE_COMMENT=51
    WHITESPACE=52

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class SAllContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SExpressionContext,0)


        def EOF(self):
            return self.getToken(HypothesisParser.EOF, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sAll

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSAll" ):
                listener.enterSAll(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSAll" ):
                listener.exitSAll(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSAll" ):
                return visitor.visitSAll(self)
            else:
                return visitor.visitChildren(self)




    def sAll(self):

        localctx = HypothesisParser.SAllContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_sAll)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.sExpression()
            self.state = 97
            self.match(HypothesisParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sNumber(self):
            return self.getTypedRuleContext(HypothesisParser.SNumberContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def sPropertyAccess(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyAccessContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSOperand" ):
                listener.enterSOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSOperand" ):
                listener.exitSOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSOperand" ):
                return visitor.visitSOperand(self)
            else:
                return visitor.visitChildren(self)




    def sOperand(self):

        localctx = HypothesisParser.SOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sOperand)
        try:
            self.state = 102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 99
                self.sNumber()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 100
                self.sProperty()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 101
                self.sPropertyAccess()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sPlus(self):
            return self.getTypedRuleContext(HypothesisParser.SPlusContext,0)


        def sMinus(self):
            return self.getTypedRuleContext(HypothesisParser.SMinusContext,0)


        def sMul(self):
            return self.getTypedRuleContext(HypothesisParser.SMulContext,0)


        def sDiv(self):
            return self.getTypedRuleContext(HypothesisParser.SDivContext,0)


        def sPower(self):
            return self.getTypedRuleContext(HypothesisParser.SPowerContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSOperator" ):
                listener.enterSOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSOperator" ):
                listener.exitSOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSOperator" ):
                return visitor.visitSOperator(self)
            else:
                return visitor.visitChildren(self)




    def sOperator(self):

        localctx = HypothesisParser.SOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_sOperator)
        try:
            self.state = 109
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.PLUS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 104
                self.sPlus()
                pass
            elif token in [HypothesisParser.MINUS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 105
                self.sMinus()
                pass
            elif token in [HypothesisParser.MUL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 106
                self.sMul()
                pass
            elif token in [HypothesisParser.DIV]:
                self.enterOuterAlt(localctx, 4)
                self.state = 107
                self.sDiv()
                pass
            elif token in [HypothesisParser.POWER]:
                self.enterOuterAlt(localctx, 5)
                self.state = 108
                self.sPower()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sConcatExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SConcatExpressionContext,0)


        def sArithmeticExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SArithmeticExpressionContext,0)


        def sBooleanExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SBooleanExpressionContext,0)


        def sNumberExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SNumberExpressionContext,0)


        def sStringExpression(self):
            return self.getTypedRuleContext(HypothesisParser.SStringExpressionContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSExpression" ):
                listener.enterSExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSExpression" ):
                listener.exitSExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSExpression" ):
                return visitor.visitSExpression(self)
            else:
                return visitor.visitChildren(self)




    def sExpression(self):

        localctx = HypothesisParser.SExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_sExpression)
        try:
            self.state = 116
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 111
                self.sConcatExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 112
                self.sArithmeticExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 113
                self.sBooleanExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 114
                self.sNumberExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 115
                self.sStringExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class STermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sArithmeticTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SArithmeticTermContext,0)


        def sBooleanTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SBooleanTermContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSTerm" ):
                listener.enterSTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSTerm" ):
                listener.exitSTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSTerm" ):
                return visitor.visitSTerm(self)
            else:
                return visitor.visitChildren(self)




    def sTerm(self):

        localctx = HypothesisParser.STermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_sTerm)
        try:
            self.state = 120
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 118
                self.sArithmeticTerm()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 119
                self.sBooleanTerm()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sNumber(self):
            return self.getTypedRuleContext(HypothesisParser.SNumberContext,0)


        def sBoolean(self):
            return self.getTypedRuleContext(HypothesisParser.SBooleanContext,0)


        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def sArray(self):
            return self.getTypedRuleContext(HypothesisParser.SArrayContext,0)


        def sMap(self):
            return self.getTypedRuleContext(HypothesisParser.SMapContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSValue" ):
                listener.enterSValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSValue" ):
                listener.exitSValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSValue" ):
                return visitor.visitSValue(self)
            else:
                return visitor.visitChildren(self)




    def sValue(self):

        localctx = HypothesisParser.SValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_sValue)
        try:
            self.state = 127
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.DIGITS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 122
                self.sNumber()
                pass
            elif token in [HypothesisParser.TRUE, HypothesisParser.FALSE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 123
                self.sBoolean()
                pass
            elif token in [HypothesisParser.CHARS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 124
                self.sString()
                pass
            elif token in [HypothesisParser.BRACKET_LEFT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 125
                self.sArray()
                pass
            elif token in [HypothesisParser.CURLY_LEFT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 126
                self.sMap()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SPlusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(HypothesisParser.PLUS, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sPlus

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSPlus" ):
                listener.enterSPlus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSPlus" ):
                listener.exitSPlus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSPlus" ):
                return visitor.visitSPlus(self)
            else:
                return visitor.visitChildren(self)




    def sPlus(self):

        localctx = HypothesisParser.SPlusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_sPlus)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(HypothesisParser.PLUS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SMinusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(HypothesisParser.MINUS, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sMinus

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSMinus" ):
                listener.enterSMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSMinus" ):
                listener.exitSMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSMinus" ):
                return visitor.visitSMinus(self)
            else:
                return visitor.visitChildren(self)




    def sMinus(self):

        localctx = HypothesisParser.SMinusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_sMinus)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(HypothesisParser.MINUS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SMulContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUL(self):
            return self.getToken(HypothesisParser.MUL, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sMul

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSMul" ):
                listener.enterSMul(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSMul" ):
                listener.exitSMul(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSMul" ):
                return visitor.visitSMul(self)
            else:
                return visitor.visitChildren(self)




    def sMul(self):

        localctx = HypothesisParser.SMulContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_sMul)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.match(HypothesisParser.MUL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SDivContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIV(self):
            return self.getToken(HypothesisParser.DIV, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sDiv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSDiv" ):
                listener.enterSDiv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSDiv" ):
                listener.exitSDiv(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSDiv" ):
                return visitor.visitSDiv(self)
            else:
                return visitor.visitChildren(self)




    def sDiv(self):

        localctx = HypothesisParser.SDivContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_sDiv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.match(HypothesisParser.DIV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SPowerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POWER(self):
            return self.getToken(HypothesisParser.POWER, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sPower

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSPower" ):
                listener.enterSPower(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSPower" ):
                listener.exitSPower(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSPower" ):
                return visitor.visitSPower(self)
            else:
                return visitor.visitChildren(self)




    def sPower(self):

        localctx = HypothesisParser.SPowerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_sPower)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(HypothesisParser.POWER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SAndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(HypothesisParser.AND, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sAnd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSAnd" ):
                listener.enterSAnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSAnd" ):
                listener.exitSAnd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSAnd" ):
                return visitor.visitSAnd(self)
            else:
                return visitor.visitChildren(self)




    def sAnd(self):

        localctx = HypothesisParser.SAndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_sAnd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.match(HypothesisParser.AND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SOrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OR(self):
            return self.getToken(HypothesisParser.OR, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sOr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSOr" ):
                listener.enterSOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSOr" ):
                listener.exitSOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSOr" ):
                return visitor.visitSOr(self)
            else:
                return visitor.visitChildren(self)




    def sOr(self):

        localctx = HypothesisParser.SOrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_sOr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self.match(HypothesisParser.OR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNotContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(HypothesisParser.NOT, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sNot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNot" ):
                listener.enterSNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNot" ):
                listener.exitSNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNot" ):
                return visitor.visitSNot(self)
            else:
                return visitor.visitChildren(self)




    def sNot(self):

        localctx = HypothesisParser.SNotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_sNot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(HypothesisParser.NOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SEqualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(HypothesisParser.EQ, 0)

        def STRICT_EQ(self):
            return self.getToken(HypothesisParser.STRICT_EQ, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sEquals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSEquals" ):
                listener.enterSEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSEquals" ):
                listener.exitSEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSEquals" ):
                return visitor.visitSEquals(self)
            else:
                return visitor.visitChildren(self)




    def sEquals(self):

        localctx = HypothesisParser.SEqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_sEquals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 145
            _la = self._input.LA(1)
            if not(_la==HypothesisParser.EQ or _la==HypothesisParser.STRICT_EQ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNotEqualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEQ(self):
            return self.getToken(HypothesisParser.NEQ, 0)

        def STRICT_NEQ(self):
            return self.getToken(HypothesisParser.STRICT_NEQ, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sNotEquals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNotEquals" ):
                listener.enterSNotEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNotEquals" ):
                listener.exitSNotEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNotEquals" ):
                return visitor.visitSNotEquals(self)
            else:
                return visitor.visitChildren(self)




    def sNotEquals(self):

        localctx = HypothesisParser.SNotEqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_sNotEquals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 147
            _la = self._input.LA(1)
            if not(_la==HypothesisParser.NEQ or _la==HypothesisParser.STRICT_NEQ):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SLowerThanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(HypothesisParser.LT, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sLowerThan

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSLowerThan" ):
                listener.enterSLowerThan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSLowerThan" ):
                listener.exitSLowerThan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSLowerThan" ):
                return visitor.visitSLowerThan(self)
            else:
                return visitor.visitChildren(self)




    def sLowerThan(self):

        localctx = HypothesisParser.SLowerThanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_sLowerThan)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            self.match(HypothesisParser.LT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SLowerEqualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LE(self):
            return self.getToken(HypothesisParser.LE, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sLowerEquals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSLowerEquals" ):
                listener.enterSLowerEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSLowerEquals" ):
                listener.exitSLowerEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSLowerEquals" ):
                return visitor.visitSLowerEquals(self)
            else:
                return visitor.visitChildren(self)




    def sLowerEquals(self):

        localctx = HypothesisParser.SLowerEqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_sLowerEquals)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(HypothesisParser.LE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SGreaterThanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GT(self):
            return self.getToken(HypothesisParser.GT, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sGreaterThan

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSGreaterThan" ):
                listener.enterSGreaterThan(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSGreaterThan" ):
                listener.exitSGreaterThan(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSGreaterThan" ):
                return visitor.visitSGreaterThan(self)
            else:
                return visitor.visitChildren(self)




    def sGreaterThan(self):

        localctx = HypothesisParser.SGreaterThanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_sGreaterThan)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            self.match(HypothesisParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SGreaterEqualsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GE(self):
            return self.getToken(HypothesisParser.GE, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sGreaterEquals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSGreaterEquals" ):
                listener.enterSGreaterEquals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSGreaterEquals" ):
                listener.exitSGreaterEquals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSGreaterEquals" ):
                return visitor.visitSGreaterEquals(self)
            else:
                return visitor.visitChildren(self)




    def sGreaterEquals(self):

        localctx = HypothesisParser.SGreaterEqualsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_sGreaterEquals)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            self.match(HypothesisParser.GE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SArithmeticExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SOperandContext,i)


        def sArithmeticTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SArithmeticTermContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SArithmeticTermContext,i)


        def sOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sArithmeticExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSArithmeticExpression" ):
                listener.enterSArithmeticExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSArithmeticExpression" ):
                listener.exitSArithmeticExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSArithmeticExpression" ):
                return visitor.visitSArithmeticExpression(self)
            else:
                return visitor.visitChildren(self)




    def sArithmeticExpression(self):

        localctx = HypothesisParser.SArithmeticExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_sArithmeticExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 159
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 157
                self.sOperand()
                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 158
                self.sArithmeticTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 166 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 161
                self.sOperator()
                self.state = 164
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                    self.state = 162
                    self.sOperand()
                    pass
                elif token in [HypothesisParser.ROUND_LEFT]:
                    self.state = 163
                    self.sArithmeticTerm()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 168 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.PLUS) | (1 << HypothesisParser.MINUS) | (1 << HypothesisParser.MUL) | (1 << HypothesisParser.DIV) | (1 << HypothesisParser.POWER))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SArithmeticTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND_LEFT(self):
            return self.getToken(HypothesisParser.ROUND_LEFT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(HypothesisParser.ROUND_RIGHT, 0)

        def sArithmeticTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SArithmeticTermContext,0)


        def sOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SOperandContext,i)


        def sOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sArithmeticTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSArithmeticTerm" ):
                listener.enterSArithmeticTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSArithmeticTerm" ):
                listener.exitSArithmeticTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSArithmeticTerm" ):
                return visitor.visitSArithmeticTerm(self)
            else:
                return visitor.visitChildren(self)




    def sArithmeticTerm(self):

        localctx = HypothesisParser.SArithmeticTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_sArithmeticTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self.match(HypothesisParser.ROUND_LEFT)
            self.state = 180
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 171
                self.sOperand()
                self.state = 175 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 172
                    self.sOperator()
                    self.state = 173
                    self.sOperand()
                    self.state = 177 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.PLUS) | (1 << HypothesisParser.MINUS) | (1 << HypothesisParser.MUL) | (1 << HypothesisParser.DIV) | (1 << HypothesisParser.POWER))) != 0)):
                        break

                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 179
                self.sArithmeticTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 182
            self.match(HypothesisParser.ROUND_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SBooleanOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sValue(self):
            return self.getTypedRuleContext(HypothesisParser.SValueContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def sPropertyAccess(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyAccessContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sBooleanOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSBooleanOperand" ):
                listener.enterSBooleanOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSBooleanOperand" ):
                listener.exitSBooleanOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSBooleanOperand" ):
                return visitor.visitSBooleanOperand(self)
            else:
                return visitor.visitChildren(self)




    def sBooleanOperand(self):

        localctx = HypothesisParser.SBooleanOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_sBooleanOperand)
        try:
            self.state = 187
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 184
                self.sValue()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 185
                self.sProperty()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 186
                self.sPropertyAccess()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SBooleanOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sAnd(self):
            return self.getTypedRuleContext(HypothesisParser.SAndContext,0)


        def sOr(self):
            return self.getTypedRuleContext(HypothesisParser.SOrContext,0)


        def sNot(self):
            return self.getTypedRuleContext(HypothesisParser.SNotContext,0)


        def sEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SEqualsContext,0)


        def sNotEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SNotEqualsContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sBooleanOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSBooleanOperator" ):
                listener.enterSBooleanOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSBooleanOperator" ):
                listener.exitSBooleanOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSBooleanOperator" ):
                return visitor.visitSBooleanOperator(self)
            else:
                return visitor.visitChildren(self)




    def sBooleanOperator(self):

        localctx = HypothesisParser.SBooleanOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_sBooleanOperator)
        try:
            self.state = 194
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.AND]:
                self.enterOuterAlt(localctx, 1)
                self.state = 189
                self.sAnd()
                pass
            elif token in [HypothesisParser.OR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 190
                self.sOr()
                pass
            elif token in [HypothesisParser.NOT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 191
                self.sNot()
                pass
            elif token in [HypothesisParser.EQ, HypothesisParser.STRICT_EQ]:
                self.enterOuterAlt(localctx, 4)
                self.state = 192
                self.sEquals()
                pass
            elif token in [HypothesisParser.NEQ, HypothesisParser.STRICT_NEQ]:
                self.enterOuterAlt(localctx, 5)
                self.state = 193
                self.sNotEquals()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SBooleanExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sBooleanOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SBooleanOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SBooleanOperandContext,i)


        def sBooleanTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SBooleanTermContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SBooleanTermContext,i)


        def sBooleanOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SBooleanOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SBooleanOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sBooleanExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSBooleanExpression" ):
                listener.enterSBooleanExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSBooleanExpression" ):
                listener.exitSBooleanExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSBooleanExpression" ):
                return visitor.visitSBooleanExpression(self)
            else:
                return visitor.visitChildren(self)




    def sBooleanExpression(self):

        localctx = HypothesisParser.SBooleanExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_sBooleanExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 196
                self.sBooleanOperand()
                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 197
                self.sBooleanTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.AND) | (1 << HypothesisParser.OR) | (1 << HypothesisParser.NOT) | (1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ))) != 0):
                self.state = 200
                self.sBooleanOperator()
                self.state = 203
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                    self.state = 201
                    self.sBooleanOperand()
                    pass
                elif token in [HypothesisParser.ROUND_LEFT]:
                    self.state = 202
                    self.sBooleanTerm()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 209
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SBooleanTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND_LEFT(self):
            return self.getToken(HypothesisParser.ROUND_LEFT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(HypothesisParser.ROUND_RIGHT, 0)

        def sBooleanTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SBooleanTermContext,0)


        def sBooleanOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SBooleanOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SBooleanOperandContext,i)


        def sBooleanOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SBooleanOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SBooleanOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sBooleanTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSBooleanTerm" ):
                listener.enterSBooleanTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSBooleanTerm" ):
                listener.exitSBooleanTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSBooleanTerm" ):
                return visitor.visitSBooleanTerm(self)
            else:
                return visitor.visitChildren(self)




    def sBooleanTerm(self):

        localctx = HypothesisParser.SBooleanTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_sBooleanTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            self.match(HypothesisParser.ROUND_LEFT)
            self.state = 220
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 211
                self.sBooleanOperand()
                self.state = 215 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 212
                    self.sBooleanOperator()
                    self.state = 213
                    self.sBooleanOperand()
                    self.state = 217 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.AND) | (1 << HypothesisParser.OR) | (1 << HypothesisParser.NOT) | (1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ))) != 0)):
                        break

                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 219
                self.sBooleanTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 222
            self.match(HypothesisParser.ROUND_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNumberOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sNumber(self):
            return self.getTypedRuleContext(HypothesisParser.SNumberContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def sPropertyAccess(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyAccessContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sNumberOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNumberOperand" ):
                listener.enterSNumberOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNumberOperand" ):
                listener.exitSNumberOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNumberOperand" ):
                return visitor.visitSNumberOperand(self)
            else:
                return visitor.visitChildren(self)




    def sNumberOperand(self):

        localctx = HypothesisParser.SNumberOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_sNumberOperand)
        try:
            self.state = 227
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 224
                self.sNumber()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 225
                self.sProperty()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 226
                self.sPropertyAccess()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNumberOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SEqualsContext,0)


        def sNotEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SNotEqualsContext,0)


        def sLowerThan(self):
            return self.getTypedRuleContext(HypothesisParser.SLowerThanContext,0)


        def sLowerEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SLowerEqualsContext,0)


        def sGreaterThan(self):
            return self.getTypedRuleContext(HypothesisParser.SGreaterThanContext,0)


        def sGreaterEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SGreaterEqualsContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sNumberOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNumberOperator" ):
                listener.enterSNumberOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNumberOperator" ):
                listener.exitSNumberOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNumberOperator" ):
                return visitor.visitSNumberOperator(self)
            else:
                return visitor.visitChildren(self)




    def sNumberOperator(self):

        localctx = HypothesisParser.SNumberOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_sNumberOperator)
        try:
            self.state = 235
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.EQ, HypothesisParser.STRICT_EQ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 229
                self.sEquals()
                pass
            elif token in [HypothesisParser.NEQ, HypothesisParser.STRICT_NEQ]:
                self.enterOuterAlt(localctx, 2)
                self.state = 230
                self.sNotEquals()
                pass
            elif token in [HypothesisParser.LT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 231
                self.sLowerThan()
                pass
            elif token in [HypothesisParser.LE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 232
                self.sLowerEquals()
                pass
            elif token in [HypothesisParser.GT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 233
                self.sGreaterThan()
                pass
            elif token in [HypothesisParser.GE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 234
                self.sGreaterEquals()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNumberExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sNumberOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberOperandContext,i)


        def sNumberTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberTermContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberTermContext,i)


        def sNumberOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sNumberExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNumberExpression" ):
                listener.enterSNumberExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNumberExpression" ):
                listener.exitSNumberExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNumberExpression" ):
                return visitor.visitSNumberExpression(self)
            else:
                return visitor.visitChildren(self)




    def sNumberExpression(self):

        localctx = HypothesisParser.SNumberExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_sNumberExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 237
                self.sNumberOperand()
                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 238
                self.sNumberTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 246 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 241
                self.sNumberOperator()
                self.state = 244
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                    self.state = 242
                    self.sNumberOperand()
                    pass
                elif token in [HypothesisParser.ROUND_LEFT]:
                    self.state = 243
                    self.sNumberTerm()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 248 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ) | (1 << HypothesisParser.LT) | (1 << HypothesisParser.LE) | (1 << HypothesisParser.GT) | (1 << HypothesisParser.GE))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNumberTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND_LEFT(self):
            return self.getToken(HypothesisParser.ROUND_LEFT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(HypothesisParser.ROUND_RIGHT, 0)

        def sNumberTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SNumberTermContext,0)


        def sNumberOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberOperandContext,i)


        def sNumberOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sNumberTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNumberTerm" ):
                listener.enterSNumberTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNumberTerm" ):
                listener.exitSNumberTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNumberTerm" ):
                return visitor.visitSNumberTerm(self)
            else:
                return visitor.visitChildren(self)




    def sNumberTerm(self):

        localctx = HypothesisParser.SNumberTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_sNumberTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(HypothesisParser.ROUND_LEFT)
            self.state = 260
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.IDENTIFIER, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 251
                self.sNumberOperand()
                self.state = 255 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 252
                    self.sNumberOperator()
                    self.state = 253
                    self.sNumberOperand()
                    self.state = 257 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ) | (1 << HypothesisParser.LT) | (1 << HypothesisParser.LE) | (1 << HypothesisParser.GT) | (1 << HypothesisParser.GE))) != 0)):
                        break

                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 259
                self.sNumberTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 262
            self.match(HypothesisParser.ROUND_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SStringOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sStringOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSStringOperand" ):
                listener.enterSStringOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSStringOperand" ):
                listener.exitSStringOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSStringOperand" ):
                return visitor.visitSStringOperand(self)
            else:
                return visitor.visitChildren(self)




    def sStringOperand(self):

        localctx = HypothesisParser.SStringOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_sStringOperand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.sString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SStringOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SEqualsContext,0)


        def sNotEquals(self):
            return self.getTypedRuleContext(HypothesisParser.SNotEqualsContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sStringOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSStringOperator" ):
                listener.enterSStringOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSStringOperator" ):
                listener.exitSStringOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSStringOperator" ):
                return visitor.visitSStringOperator(self)
            else:
                return visitor.visitChildren(self)




    def sStringOperator(self):

        localctx = HypothesisParser.SStringOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_sStringOperator)
        try:
            self.state = 268
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.EQ, HypothesisParser.STRICT_EQ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 266
                self.sEquals()
                pass
            elif token in [HypothesisParser.NEQ, HypothesisParser.STRICT_NEQ]:
                self.enterOuterAlt(localctx, 2)
                self.state = 267
                self.sNotEquals()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SStringExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sStringOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringOperandContext,i)


        def sStringTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringTermContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringTermContext,i)


        def sStringOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sStringExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSStringExpression" ):
                listener.enterSStringExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSStringExpression" ):
                listener.exitSStringExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSStringExpression" ):
                return visitor.visitSStringExpression(self)
            else:
                return visitor.visitChildren(self)




    def sStringExpression(self):

        localctx = HypothesisParser.SStringExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_sStringExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 272
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.CHARS]:
                self.state = 270
                self.sStringOperand()
                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 271
                self.sStringTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 279 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 274
                self.sStringOperator()
                self.state = 277
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [HypothesisParser.CHARS]:
                    self.state = 275
                    self.sStringOperand()
                    pass
                elif token in [HypothesisParser.ROUND_LEFT]:
                    self.state = 276
                    self.sStringTerm()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 281 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SStringTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROUND_LEFT(self):
            return self.getToken(HypothesisParser.ROUND_LEFT, 0)

        def ROUND_RIGHT(self):
            return self.getToken(HypothesisParser.ROUND_RIGHT, 0)

        def sStringTerm(self):
            return self.getTypedRuleContext(HypothesisParser.SStringTermContext,0)


        def sStringOperand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringOperandContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringOperandContext,i)


        def sStringOperator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringOperatorContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringOperatorContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sStringTerm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSStringTerm" ):
                listener.enterSStringTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSStringTerm" ):
                listener.exitSStringTerm(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSStringTerm" ):
                return visitor.visitSStringTerm(self)
            else:
                return visitor.visitChildren(self)




    def sStringTerm(self):

        localctx = HypothesisParser.SStringTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_sStringTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            self.match(HypothesisParser.ROUND_LEFT)
            self.state = 293
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.CHARS]:
                self.state = 284
                self.sStringOperand()
                self.state = 288 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 285
                    self.sStringOperator()
                    self.state = 286
                    self.sStringOperand()
                    self.state = 290 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.EQ) | (1 << HypothesisParser.STRICT_EQ) | (1 << HypothesisParser.NEQ) | (1 << HypothesisParser.STRICT_NEQ))) != 0)):
                        break

                pass
            elif token in [HypothesisParser.ROUND_LEFT]:
                self.state = 292
                self.sStringTerm()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 295
            self.match(HypothesisParser.ROUND_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SConcatOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sConcatOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSConcatOperand" ):
                listener.enterSConcatOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSConcatOperand" ):
                listener.exitSConcatOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSConcatOperand" ):
                return visitor.visitSConcatOperand(self)
            else:
                return visitor.visitChildren(self)




    def sConcatOperand(self):

        localctx = HypothesisParser.SConcatOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_sConcatOperand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self.sString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SConcatExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sConcatBoth(self):
            return self.getTypedRuleContext(HypothesisParser.SConcatBothContext,0)


        def sConcatLeft(self):
            return self.getTypedRuleContext(HypothesisParser.SConcatLeftContext,0)


        def sConcatRight(self):
            return self.getTypedRuleContext(HypothesisParser.SConcatRightContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sConcatExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSConcatExpression" ):
                listener.enterSConcatExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSConcatExpression" ):
                listener.exitSConcatExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSConcatExpression" ):
                return visitor.visitSConcatExpression(self)
            else:
                return visitor.visitChildren(self)




    def sConcatExpression(self):

        localctx = HypothesisParser.SConcatExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_sConcatExpression)
        try:
            self.state = 302
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 299
                self.sConcatBoth()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 300
                self.sConcatLeft()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 301
                self.sConcatRight()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SConcatLeftContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def sPlus(self):
            return self.getTypedRuleContext(HypothesisParser.SPlusContext,0)


        def sValue(self):
            return self.getTypedRuleContext(HypothesisParser.SValueContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sConcatLeft

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSConcatLeft" ):
                listener.enterSConcatLeft(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSConcatLeft" ):
                listener.exitSConcatLeft(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSConcatLeft" ):
                return visitor.visitSConcatLeft(self)
            else:
                return visitor.visitChildren(self)




    def sConcatLeft(self):

        localctx = HypothesisParser.SConcatLeftContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_sConcatLeft)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.sString()
            self.state = 305
            self.sPlus()
            self.state = 308
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 306
                self.sValue()
                pass
            elif token in [HypothesisParser.IDENTIFIER]:
                self.state = 307
                self.sProperty()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SConcatRightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sPlus(self):
            return self.getTypedRuleContext(HypothesisParser.SPlusContext,0)


        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def sValue(self):
            return self.getTypedRuleContext(HypothesisParser.SValueContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sConcatRight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSConcatRight" ):
                listener.enterSConcatRight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSConcatRight" ):
                listener.exitSConcatRight(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSConcatRight" ):
                return visitor.visitSConcatRight(self)
            else:
                return visitor.visitChildren(self)




    def sConcatRight(self):

        localctx = HypothesisParser.SConcatRightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_sConcatRight)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 312
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.TRUE, HypothesisParser.FALSE, HypothesisParser.CURLY_LEFT, HypothesisParser.BRACKET_LEFT, HypothesisParser.CHARS, HypothesisParser.DIGITS]:
                self.state = 310
                self.sValue()
                pass
            elif token in [HypothesisParser.IDENTIFIER]:
                self.state = 311
                self.sProperty()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 314
            self.sPlus()
            self.state = 315
            self.sString()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SConcatBothContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringContext,i)


        def sPlus(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SPlusContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SPlusContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sConcatBoth

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSConcatBoth" ):
                listener.enterSConcatBoth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSConcatBoth" ):
                listener.exitSConcatBoth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSConcatBoth" ):
                return visitor.visitSConcatBoth(self)
            else:
                return visitor.visitChildren(self)




    def sConcatBoth(self):

        localctx = HypothesisParser.SConcatBothContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_sConcatBoth)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 317
            self.sString()
            self.state = 321 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 318
                self.sPlus()
                self.state = 319
                self.sString()
                self.state = 323 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==HypothesisParser.PLUS):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class STypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(HypothesisParser.STRING, 0)

        def NUMBER(self):
            return self.getToken(HypothesisParser.NUMBER, 0)

        def BOOLEAN(self):
            return self.getToken(HypothesisParser.BOOLEAN, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSType" ):
                listener.enterSType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSType" ):
                listener.exitSType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSType" ):
                return visitor.visitSType(self)
            else:
                return visitor.visitChildren(self)




    def sType(self):

        localctx = HypothesisParser.STypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_sType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.STRING) | (1 << HypothesisParser.NUMBER) | (1 << HypothesisParser.BOOLEAN))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SPropertyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(HypothesisParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sProperty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSProperty" ):
                listener.enterSProperty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSProperty" ):
                listener.exitSProperty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSProperty" ):
                return visitor.visitSProperty(self)
            else:
                return visitor.visitChildren(self)




    def sProperty(self):

        localctx = HypothesisParser.SPropertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_sProperty)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 327
            self.match(HypothesisParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SPropertyAwareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sString(self):
            return self.getTypedRuleContext(HypothesisParser.SStringContext,0)


        def sProperty(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyContext,0)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sPropertyAware

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSPropertyAware" ):
                listener.enterSPropertyAware(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSPropertyAware" ):
                listener.exitSPropertyAware(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSPropertyAware" ):
                return visitor.visitSPropertyAware(self)
            else:
                return visitor.visitChildren(self)




    def sPropertyAware(self):

        localctx = HypothesisParser.SPropertyAwareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_sPropertyAware)
        try:
            self.state = 331
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [HypothesisParser.CHARS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 329
                self.sString()
                pass
            elif token in [HypothesisParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 330
                self.sProperty()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SPropertyAccessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sPropertyAware(self):
            return self.getTypedRuleContext(HypothesisParser.SPropertyAwareContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.DOT)
            else:
                return self.getToken(HypothesisParser.DOT, i)

        def sProperty(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SPropertyContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SPropertyContext,i)


        def BRACKET_LEFT(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.BRACKET_LEFT)
            else:
                return self.getToken(HypothesisParser.BRACKET_LEFT, i)

        def BRACKET_RIGHT(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.BRACKET_RIGHT)
            else:
                return self.getToken(HypothesisParser.BRACKET_RIGHT, i)

        def sNumber(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SNumberContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SNumberContext,i)


        def sString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringContext,i)


        def getRuleIndex(self):
            return HypothesisParser.RULE_sPropertyAccess

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSPropertyAccess" ):
                listener.enterSPropertyAccess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSPropertyAccess" ):
                listener.exitSPropertyAccess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSPropertyAccess" ):
                return visitor.visitSPropertyAccess(self)
            else:
                return visitor.visitChildren(self)




    def sPropertyAccess(self):

        localctx = HypothesisParser.SPropertyAccessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_sPropertyAccess)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 333
            self.sPropertyAware()
            self.state = 343 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 343
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [HypothesisParser.DOT]:
                    self.state = 334
                    self.match(HypothesisParser.DOT)
                    self.state = 335
                    self.sProperty()
                    pass
                elif token in [HypothesisParser.BRACKET_LEFT]:
                    self.state = 336
                    self.match(HypothesisParser.BRACKET_LEFT)
                    self.state = 339
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [HypothesisParser.DIGITS]:
                        self.state = 337
                        self.sNumber()
                        pass
                    elif token in [HypothesisParser.CHARS]:
                        self.state = 338
                        self.sString()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 341
                    self.match(HypothesisParser.BRACKET_RIGHT)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 345 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==HypothesisParser.DOT or _la==HypothesisParser.BRACKET_LEFT):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SStringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHARS(self):
            return self.getToken(HypothesisParser.CHARS, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sString

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSString" ):
                listener.enterSString(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSString" ):
                listener.exitSString(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSString" ):
                return visitor.visitSString(self)
            else:
                return visitor.visitChildren(self)




    def sString(self):

        localctx = HypothesisParser.SStringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_sString)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 347
            self.match(HypothesisParser.CHARS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SNumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGITS(self):
            return self.getToken(HypothesisParser.DIGITS, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sNumber

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSNumber" ):
                listener.enterSNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSNumber" ):
                listener.exitSNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSNumber" ):
                return visitor.visitSNumber(self)
            else:
                return visitor.visitChildren(self)




    def sNumber(self):

        localctx = HypothesisParser.SNumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_sNumber)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 349
            self.match(HypothesisParser.DIGITS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SBooleanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(HypothesisParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(HypothesisParser.FALSE, 0)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sBoolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSBoolean" ):
                listener.enterSBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSBoolean" ):
                listener.exitSBoolean(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSBoolean" ):
                return visitor.visitSBoolean(self)
            else:
                return visitor.visitChildren(self)




    def sBoolean(self):

        localctx = HypothesisParser.SBooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_sBoolean)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 351
            _la = self._input.LA(1)
            if not(_la==HypothesisParser.TRUE or _la==HypothesisParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SArrayContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BRACKET_LEFT(self):
            return self.getToken(HypothesisParser.BRACKET_LEFT, 0)

        def BRACKET_RIGHT(self):
            return self.getToken(HypothesisParser.BRACKET_RIGHT, 0)

        def sValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SValueContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SValueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.COMMA)
            else:
                return self.getToken(HypothesisParser.COMMA, i)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sArray

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSArray" ):
                listener.enterSArray(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSArray" ):
                listener.exitSArray(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSArray" ):
                return visitor.visitSArray(self)
            else:
                return visitor.visitChildren(self)




    def sArray(self):

        localctx = HypothesisParser.SArrayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_sArray)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 353
            self.match(HypothesisParser.BRACKET_LEFT)
            self.state = 362
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << HypothesisParser.TRUE) | (1 << HypothesisParser.FALSE) | (1 << HypothesisParser.CURLY_LEFT) | (1 << HypothesisParser.BRACKET_LEFT) | (1 << HypothesisParser.CHARS) | (1 << HypothesisParser.DIGITS))) != 0):
                self.state = 354
                self.sValue()
                self.state = 359
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==HypothesisParser.COMMA:
                    self.state = 355
                    self.match(HypothesisParser.COMMA)
                    self.state = 356
                    self.sValue()
                    self.state = 361
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 364
            self.match(HypothesisParser.BRACKET_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SMapContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CURLY_LEFT(self):
            return self.getToken(HypothesisParser.CURLY_LEFT, 0)

        def CURLY_RIGHT(self):
            return self.getToken(HypothesisParser.CURLY_RIGHT, 0)

        def sString(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SStringContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SStringContext,i)


        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.COLON)
            else:
                return self.getToken(HypothesisParser.COLON, i)

        def sValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HypothesisParser.SValueContext)
            else:
                return self.getTypedRuleContext(HypothesisParser.SValueContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(HypothesisParser.COMMA)
            else:
                return self.getToken(HypothesisParser.COMMA, i)

        def getRuleIndex(self):
            return HypothesisParser.RULE_sMap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSMap" ):
                listener.enterSMap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSMap" ):
                listener.exitSMap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSMap" ):
                return visitor.visitSMap(self)
            else:
                return visitor.visitChildren(self)




    def sMap(self):

        localctx = HypothesisParser.SMapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_sMap)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 366
            self.match(HypothesisParser.CURLY_LEFT)
            self.state = 380
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==HypothesisParser.CHARS:
                self.state = 367
                self.sString()
                self.state = 368
                self.match(HypothesisParser.COLON)
                self.state = 369
                self.sValue()
                self.state = 377
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==HypothesisParser.COMMA:
                    self.state = 370
                    self.match(HypothesisParser.COMMA)
                    self.state = 371
                    self.sString()
                    self.state = 372
                    self.match(HypothesisParser.COLON)
                    self.state = 373
                    self.sValue()
                    self.state = 379
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 382
            self.match(HypothesisParser.CURLY_RIGHT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





